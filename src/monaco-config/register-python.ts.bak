/**
 * Регистрация поддержки Python в Monaco Editor
 */

import * as monaco from 'monaco-editor';
import { invoke } from '@tauri-apps/api/core';
import { 
  updateAllPythonDiagnostics, 
  isPythonLSPConnected, 
  forcePythonDiagnosticsUpdate,
  clearAllPythonDiagnostics
} from '../main-screen/centerContainer/python-lsp-starter';
import { MonacoLSPDiagnostics } from '../main-screen/centerContainer/monaco-lsp-diagnostics';
import { loadPylanceFromCDN, PylanceAPI } from './pylance-loader';

interface IPythonDiagnostic {
  severity: 'error' | 'warning' | 'info';
  message: string;
  line: number;
  column: number;
  endLine: number;
  endColumn: number;
  source: string;
}

interface IPythonMarker extends monaco.editor.IMarkerData {
  owner: string;
  resource: monaco.Uri;
}

// Объявляем глобальные переменные с правильными типами
declare global {
  interface Window {
    updatePythonDiagnostics?: (filePath?: string) => Promise<string>;
    registerPythonForModel?: (model: monaco.editor.ITextModel) => void;
    forceUpdateAllDecorations?: () => void;
    setupErrorDecorations?: (editor: any) => void;
    setupAllErrorDecorations?: () => void;
    globalMarkersStore?: Map<string, any[]>;
    monaco?: any;
    pythonDiagnosticsStore?: any;
    pylance?: any;
    globalMarkers?: Map<string, any[]>;
    applyNoLineWrap?: (editor: any) => void;
  }
}

// Интерфейс для pip пакетов
interface PipPackage {
  name: string;
  version: string;
}

// Кэш pip пакетов
let pipPackagesCache: PipPackage[] = [];
let pipPackagesLoaded = false;

/**
 * Загружает список установленных pip пакетов
 */
async function loadPipPackages(): Promise<PipPackage[]> {
  if (pipPackagesLoaded && pipPackagesCache.length > 0) {
    return pipPackagesCache;
  }

  try {
    console.log('Загрузка установленных pip пакетов...');
    const packages = await invoke<PipPackage[]>('get_pip_packages');
    pipPackagesCache = packages;
    pipPackagesLoaded = true;
    console.log(`Загружено ${packages.length} pip пакетов`);
    return packages;
  } catch (error) {
    console.error('Ошибка при загрузке pip пакетов:', error);
    return [];
  }
}

// Хранилище для отслеживания последних примененных маркеров для каждого редактора
let lastMarkersCache = new Map();
// Таймеры для дебаунсинга декораций
let decorationTimers = new Map();
// Глобальное хранилище всех маркеров для всех URI
let globalMarkers = new Map();

function mapSeverityToMonaco(severity: string): monaco.MarkerSeverity {
  switch (severity) {
    case 'error':
      return monaco.MarkerSeverity.Error;
    case 'warning':
      return monaco.MarkerSeverity.Warning;
    case 'info':
      return monaco.MarkerSeverity.Info;
    default:
      return monaco.MarkerSeverity.Warning;
  }
}

function createMarkerData(diagnostic: IPythonDiagnostic): monaco.editor.IMarkerData {
  return {
    severity: mapSeverityToMonaco(diagnostic.severity),
    message: diagnostic.message,
    startLineNumber: diagnostic.line,
    startColumn: diagnostic.column,
    endLineNumber: diagnostic.endLine,
    endColumn: diagnostic.endColumn,
    source: diagnostic.source
  };
}

function createDecorations(markers, model) {
  if (!markers || !Array.isArray(markers) || markers.length === 0) return [];
  
  return markers.map(marker => {
    if (!marker) return null;
    
    const isError = marker.severity === monaco.MarkerSeverity.Error;
    const classType = isError ? 'error' : 'warning';
    
    try {
      // Создаем декорацию для маркера
      return {
        range: new monaco.Range(
          marker.startLineNumber || 1,
          marker.startColumn || 1,
          marker.endLineNumber || (marker.startLineNumber || 1),
          marker.endColumn || (marker.startColumn || 1) + 1
        ),
        options: {
          inlineClassName: `${classType}-text`,
          hoverMessage: { value: marker.message || (isError ? 'Ошибка' : 'Предупреждение') },
          stickiness: monaco.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
          zIndex: 1
        }
      };
    } catch (e) {
      console.warn('Ошибка при создании декорации:', e);
      return null;
    }
  }).filter(Boolean);
}

function setupErrorDecorations(editor: monaco.editor.IStandaloneCodeEditor): void {
  try {
    if (!editor) {
      console.error('setupErrorDecorations: editor is null or undefined');
      return;
    }

    const model = editor.getModel();
    if (!model) {
      console.error('setupErrorDecorations: model is null or undefined');
      return;
    }

    // Настраиваем опции редактора для правильного отображения ошибок
    editor.updateOptions({
      glyphMargin: true,  // Включаем поле для глифов
      lineHeight: 18,     // Фиксированная высота строк
      lineDecorationsWidth: 10,  // Уменьшаем ширину для декораций
      renderLineHighlight: 'none',  // Отключаем подсветку линий
      folding: true,
      fixedOverflowWidgets: true,  // Улучшает поведение всплывающих окон
      scrollBeyondLastLine: false  // Улучшает вертикальное выравнивание
    });

    // Получаем маркеры для модели
    const markers = monaco.editor.getModelMarkers({ resource: model.uri });
    
    // Если нет маркеров, очищаем декорации
    if (!markers || markers.length === 0) {
      editor.deltaDecorations([], []);
      return;
    }

    // Создаем декорации с использованием нашей функции
    const decorations = createDecorations(markers, model);
    
    // Применяем декорации
    const oldDecorations = editor.getDecorationsInRange(
      new monaco.Range(1, 1, model.getLineCount(), model.getLineMaxColumn(model.getLineCount()))
    ) || [];
    
    const oldDecorationIds = oldDecorations
      .filter(d => d.options.className?.includes('error') || d.options.className?.includes('warning'))
      .map(d => d.id);
    
    editor.deltaDecorations(oldDecorationIds, decorations);
    
    // Принудительно перерисовываем редактор для применения изменений
    setTimeout(() => {
      editor.layout();
      editor.render(true);
    }, 10);
  } catch (error) {
    console.error('Error in setupErrorDecorations:', error);
  }
}

/**
 * Регистрирует поддержку Python в Monaco Editor, используя встроенный анализатор или Pylance
 * @returns Успешность регистрации
 */
export function registerPython(): boolean {
  try {
    console.log('Регистрация поддержки Python...');
    
    // Проверяем наличие Monaco
    if (!window.monaco) {
      console.error('Monaco не определен. Невозможно зарегистрировать поддержку Python.');
      return false;
    }
    
    const monaco = window.monaco;
    
    // Создаем хранилище диагностики Python
    if (!window.pythonDiagnosticsStore) {
      console.log('Создание хранилища диагностики Python...');
      (window as any).pythonDiagnosticsStore = {
        markers: new Map(),
        setMarkers: function(uri: string, diagnostics: any[]) {
          this.markers.set(uri, diagnostics);
          console.log(`Установлено ${diagnostics.length} маркеров для ${uri}`);
          
          // Находим модель и применяем маркеры напрямую
          try {
            const models = window.monaco.editor.getModels();
            const model = models.find((m: any) => {
              const modelPath = m.uri.path;
              return modelPath === uri || 
                     modelPath.endsWith(uri) || 
                     m.uri.toString().includes(uri);
            });
            
            if (model) {
              // Преобразуем диагностику в формат Monaco маркеров
              const markers = diagnostics.map((diag: any) => ({
                severity: mapSeverityToMonaco(diag.severity || 'warning'),
                startLineNumber: diag.range.start.line + 1,
                startColumn: diag.range.start.character + 1,
                endLineNumber: diag.range.end.line + 1,
                endColumn: diag.range.end.character + 1,
                message: diag.message,
                source: 'Pylance'
              }));
              
              window.monaco.editor.setModelMarkers(model, 'python', markers);
              console.log(`✅ Установлены ${markers.length} маркеров для модели ${model.uri.toString()}`);
            }
          } catch (err) {
            console.error('Ошибка при прямом применении маркеров:', err);
          }
          
          // Отправляем событие обновления маркеров
          try {
            const event = new CustomEvent('markers-updated', { 
              detail: { uri, count: diagnostics.length, diagnostics } 
            });
            document.dispatchEvent(event);
          } catch (err) {
            console.warn('Ошибка при отправке события обновления маркеров:', err);
          }
        },
        getMarkers: function(uri: string) {
          return this.markers.get(uri) || [];
        },
        getAllMarkersForUI: function() {
          const result: any[] = [];
          const processedUris = new Set<string>(); // Отслеживаем обработанные URI
          
          this.markers.forEach((diagnostics: any[], uri: string) => {
            if (diagnostics && diagnostics.length > 0) {
              // Нормализуем URI, чтобы избежать дублирования
              let normalizedUri = uri;
              try {
                // Удаляем URL-кодирование из пути
                if (uri.includes('%')) {
                  normalizedUri = decodeURIComponent(uri);
                }
                
                // Очищаем путь от схемы file://
                if (normalizedUri.startsWith('file://')) {
                  normalizedUri = normalizedUri.replace('file://', '');
                }
                
                // Заменяем обратные слеши на прямые для единообразия
                normalizedUri = normalizedUri.replace(/\\/g, '/');
              } catch (e) {
                console.warn('Ошибка при нормализации URI:', e);
              }
              
              // Пропускаем дубликаты URI
              if (processedUris.has(normalizedUri)) {
                return;
              }
              processedUris.add(normalizedUri);
              
              // Получаем имя файла из URI
              let fileName = normalizedUri.split('/').pop() || '';
              
              // Создаем запись для файла
              result.push({
                filePath: normalizedUri,
                fileName: fileName,
                issues: diagnostics.map((diag: any) => {
                  // Определяем тип проблемы
                  let severity = diag.severity === 'error' ? 'error' : 
                                 diag.severity === 'warning' ? 'warning' : 'info';
                  
                  // Преобразуем позицию из формата LSP в формат UI
                  let line = (diag.range?.start?.line !== undefined) ? diag.range.start.line + 1 : 1;
                  let column = (diag.range?.start?.character !== undefined) ? diag.range.start.character + 1 : 1;
                  let endLine = (diag.range?.end?.line !== undefined) ? diag.range.end.line + 1 : line;
                  let endColumn = (diag.range?.end?.character !== undefined) ? diag.range.end.character + 1 : column;
                  
                  return {
                    severity: severity,
                    message: diag.message || 'Ошибка в Python коде',
                    line: line,
                    column: column,
                    endLine: endLine,
                    endColumn: endColumn,
                    source: diag.source || 'python-validator',
                    code: diag.code
                  };
                })
              });
            }
          });
          return result;
        }
      };
      
      // Глобальная функция для доступа к маркерам Python
      (window as any).getPythonDiagnostics = () => {
        if (window.pythonDiagnosticsStore && 
            typeof window.pythonDiagnosticsStore.getAllMarkersForUI === 'function') {
          return window.pythonDiagnosticsStore.getAllMarkersForUI();
        }
        return [];
      };
    }
    
    // Добавляем функцию для маппинга уровней серьезности ошибок
    function mapSeverity(severity: number): number {
      // Соответствие LSP и Monaco уровней серьезности
      // LSP: 1 = Error, 2 = Warning, 3 = Information, 4 = Hint
      // Monaco: 8 = Error, 4 = Warning, 2 = Info, 1 = Hint
      switch(severity) {
        case 1: return monaco.MarkerSeverity.Error;
        case 2: return monaco.MarkerSeverity.Warning;
        case 3: return monaco.MarkerSeverity.Info;
        case 4: return monaco.MarkerSeverity.Hint;
        default: return monaco.MarkerSeverity.Warning;
      }
    }
    
    // Добавляем функцию регистрации Python для модели
    window.registerPythonForModel = (model: monaco.editor.ITextModel) => {
      try {
        // Проверяем, что модель существует и имеет URI
        if (!model || !model.uri) {
          console.warn('Невозможно зарегистрировать Python для недействительной модели');
          return;
        }

        // Проверяем, является ли файл Python файлом
        const uri = model.uri.toString();
        const isPythonFile = uri.endsWith('.py') || uri.endsWith('.pyi') || model.getLanguageId() === 'python';
        if (!isPythonFile) {
          return;
        }
        
        console.log(`Регистрация Python-поддержки для модели: ${uri}`);
        
        // Устанавливаем базовую Python-поддержку и диагностику для файла
        setTimeout(() => {
          try {
            // Выполняем базовую проверку синтаксиса Python и устанавливаем маркеры
            const content = model.getValue();
            if (!content) {
              console.log('Пропуск пустого файла');
              return;
            }
            
            // Выполняем расширенную проверку ошибок
            runExtendedErrorChecks(model);
            
            // Пытаемся обновить Python диагностику
            setTimeout(() => {
              try {
                if (window.updatePythonDiagnostics && typeof window.updatePythonDiagnostics === 'function') {
                  window.updatePythonDiagnostics(uri)
                    .catch(error => {
                      console.error(`Ошибка при обновлении Python диагностики для ${uri}:`, error);
                    });
                }
              } catch (error) {
                console.error('Ошибка при вызове updatePythonDiagnostics:', error);
              }
            }, 500);  // Добавляем таймаут в 500 мс для предотвращения избыточных вызовов
          } catch (error) {
            console.error('Ошибка при базовой проверке синтаксиса Python:', error);
          }
        }, 100);
      } catch (error) {
        console.error('Ошибка при регистрации Python для модели:', error);
      }
    };
    
    // Функция для выполнения расширенной проверки ошибок
    function runExtendedErrorChecks(model: monaco.editor.ITextModel): void {
      if (!model) return;

      const content = model.getValue();
      const lines = content.split('\n');
      const diagnostics: IPythonDiagnostic[] = [];

      lines.forEach((line, index) => {
        // Проверка деления на ноль
        const divisionByZeroMatch = line.match(/\b(\w+\s*(?:\[\s*\w+\s*\])?\s*)?\/\s*(0|0\.0*)\b/);
        if (divisionByZeroMatch) {
          diagnostics.push({
            severity: 'error',
            message: '⚠️ Ошибка: деление на ноль',
            line: index + 1,
            column: line.indexOf(divisionByZeroMatch[0]) + 1,
            endLine: index + 1,
            endColumn: line.indexOf(divisionByZeroMatch[0]) + divisionByZeroMatch[0].length + 1,
            source: 'Python Validator'
          });
        }

        // Проверка синтаксиса с двоеточием
        if (line.match(/^\s*(if|for|while|def|class|with|try|except|finally)\s+[^:]*$/)) {
          diagnostics.push({
            severity: 'error',
            message: '❌ Синтаксическая ошибка: отсутствует двоеточие',
            line: index + 1,
            column: 1,
            endLine: index + 1,
            endColumn: line.length + 1,
            source: 'Python Validator'
          });
        }
      });

      // Преобразуем диагностику в маркеры Monaco
      const markers = diagnostics.map(createMarkerData);
      monaco.editor.setModelMarkers(model, 'python', markers);
    }
    
    // Регистрируем язык Python, если еще не зарегистрирован
    const languages = monaco.languages.getLanguages();
    const pythonRegistered = languages.some((lang: { id: string }) => lang.id === 'python');
    
    if (!pythonRegistered) {
      // Регистрируем язык Python
      monaco.languages.register({
        id: 'python',
        extensions: ['.py', '.pyw', '.pyi'],
        aliases: ['Python', 'python'],
        mimetypes: ['text/x-python', 'text/python'],
      });
      console.log('Python язык зарегистрирован в Monaco');
    }
    
    // Убедимся, что Python определяется правильно через расширение файла
    monaco.editor.onDidCreateModel((model: any) => {
      try {
        if (window.registerPythonForModel && typeof window.registerPythonForModel === 'function') {
          window.registerPythonForModel(model);
          
          // Добавляем обработчик изменений для автоматической диагностики
          if (model && model.getLanguageId() === 'python') {
            // Устанавливаем слушатель изменений с небольшой задержкой для анализа
            let updateTimeout: any = null;
            model.onDidChangeContent(() => {
              if (updateTimeout) {
                clearTimeout(updateTimeout);
              }
              
              updateTimeout = setTimeout(() => {
                if (window.updatePythonDiagnostics && typeof window.updatePythonDiagnostics === 'function') {
                  window.updatePythonDiagnostics(model.uri.toString())
                    .catch(err => console.error('Ошибка при автоматическом обновлении Python диагностики:', err));
                }
              }, 500);
            });
            
            // Запускаем немедленный анализ при создании модели
            setTimeout(() => {
              if (window.updatePythonDiagnostics && typeof window.updatePythonDiagnostics === 'function') {
                window.updatePythonDiagnostics(model.uri.toString())
                  .catch(err => console.error('Ошибка при инициализации Python диагностики:', err));
              }
              
              // Включаем отображение поля глифов во всех редакторах с этой моделью
              try {
                const editors = monaco.editor.getEditors();
                editors.forEach((editor: any) => {
                  if (editor.getModel() === model) {
                    editor.updateOptions({ glyphMargin: true });
                    console.log('Включено поле глифов для редактора Python');
                  }
                });
              } catch (err) {
                console.warn('Не удалось включить поле глифов:', err);
              }
            }, 100);
          }
        }
      } catch (error) {
        console.error('Ошибка при обработке новой модели Python:', error);
      }
    });
    
    // Проверяем существующие модели на наличие Python файлов
    setTimeout(() => {
      try {
        const models = monaco.editor.getModels();
        console.log(`Проверка ${models.length} существующих моделей на Python файлы...`);
        
        models.forEach((model: monaco.editor.ITextModel) => {
          if (window.registerPythonForModel && typeof window.registerPythonForModel === 'function') {
            window.registerPythonForModel(model);
          }
        });
      } catch (error) {
        console.error('Ошибка при проверке существующих моделей:', error);
      }
    }, 1000);
    
    // Пытаемся загрузить Pylance для улучшенного опыта
    initializePylance().catch(err => {
      console.warn('Не удалось инициализировать Pylance, используем встроенный анализатор:', err);
      
      // Если Pylance не загрузился, используем встроенное автодополнение
      setupBuiltinPythonSupport(monaco);
    });
    
    // Предзагружаем pip пакеты для автодополнения
    loadPipPackages().catch(err => console.error('Ошибка при предзагрузке pip пакетов:', err));

    // Добавляем глобальные функции для работы с диагностикой Python
    (window as any).updatePythonDiagnostics = async (filePath: string) => {
      try {
        console.log('Обновление встроенной диагностики Python для файла:', filePath);
        
        // Получаем содержимое файла из Monaco, если есть модель
        let content = '';
        let model = null;
        
        if (monaco && monaco.editor) {
          try {
            const models = monaco.editor.getModels();
            model = models.find((m: any) => {
              const modelPath = m.uri.path;
              return modelPath === filePath || 
                     modelPath.endsWith(filePath) || 
                     m.uri.toString().includes(filePath);
            });
            
            if (model) {
              content = model.getValue();
              console.log(`Получено содержимое для ${filePath} из Monaco модели`);
            }
          } catch (err) {
            console.warn('Ошибка при получении содержимого из модели Monaco:', err);
          }
        }
        
        // Если не удалось получить из Monaco, пробуем через Tauri
        if (!content) {
          try {
            content = await invoke('read_file', { path: filePath }) as string;
            console.log(`Получено содержимое для ${filePath} через Tauri API`);
          } catch (err) {
            console.error('Ошибка при чтении файла через Tauri:', err);
            return `error: Не удалось прочитать файл ${filePath}`;
          }
        }
        
        if (!content) {
          return `error: Пустое содержимое файла ${filePath}`;
        }
        
        // Проверяем, есть ли у нас доступ к Pylance API
        if (window.pylance && typeof window.pylance.provideDiagnostics === 'function') {
          try {
            console.log('Использование Pylance API для диагностики');
            const pylance = window.pylance;
            const diagnostics = await pylance.provideDiagnostics(filePath, content);
            
            if (diagnostics && Array.isArray(diagnostics)) {
              console.log(`Получено ${diagnostics.length} диагностических сообщений от Pylance`);
              
              // Убедимся что хранилище диагностики для Python существует
              if (!window.pythonDiagnosticsStore) {
                console.log('⚡ Создаем хранилище диагностики Python во время обработки ошибок');
                (window as any).pythonDiagnosticsStore = {
                  markers: new Map(),
                  setMarkers: function(uri: string, diagnostics: any[]) {
                    this.markers.set(uri, diagnostics);
                    console.log(`Установлено ${diagnostics.length} маркеров для ${uri}`);
                    
                    // Отправляем событие обновления маркеров
                    try {
                      const event = new CustomEvent('markers-updated', { 
                        detail: { uri, count: diagnostics.length, diagnostics } 
                      });
                      document.dispatchEvent(event);
                    } catch (err) {
                      console.warn('Ошибка при отправке события обновления маркеров:', err);
                    }
                  },
                  getMarkers: function(uri: string) {
                    return this.markers.get(uri) || [];
                  }
                };
              }
              
              // Обновляем хранилище маркеров
              window.pythonDiagnosticsStore.setMarkers(filePath, diagnostics);
              
              // Если у нас есть модель, устанавливаем маркеры напрямую
              if (model) {
                const markers = diagnostics.map((diag: any) => ({
                  severity: mapSeverity(diag.severity || 1),
                  startLineNumber: diag.range.start.line + 1,
                  startColumn: diag.range.start.character + 1,
                  endLineNumber: diag.range.end.line + 1,
                  endColumn: diag.range.end.character + 1,
                  message: diag.message,
                  source: 'Pylance'
                }));
                
                monaco.editor.setModelMarkers(model, 'python', markers);
                console.log(`Установлено ${markers.length} маркеров напрямую для модели`);
              }
            }
            
            // Обновляем визуальное отображение в любом случае
            setTimeout(() => {
              if (window.monaco && window.setupErrorDecorations && typeof window.setupErrorDecorations === 'function') {
                const editors = window.monaco.editor.getEditors();
                if (editors && editors.length > 0) {
                  console.log(`🎨 Обновление декораций для ${editors.length} редакторов после Python диагностики`);
                  editors.forEach((editor: any) => {
                    try {
                      if (window.setupErrorDecorations) {
                        window.setupErrorDecorations(editor);
                      }
                    } catch (err) {
                      console.warn('Ошибка при обновлении декораций:', err);
                    }
                  });
                }
              }
              
              // Отправляем событие для обновления панели проблем
              try {
                const problemsEvent = new CustomEvent('python-diagnostics-updated', { 
                  detail: { diagnostics: window.pythonDiagnosticsStore?.getAllMarkersForUI() || [] } 
                });
                document.dispatchEvent(problemsEvent);
              } catch (err) {
                console.warn('Ошибка при отправке события обновления панели проблем:', err);
              }
            }, 100);
            
            return 'success';
          } catch (pylanceError) {
            console.error('Ошибка при использовании Pylance API:', pylanceError);
            // Продолжаем с LSP-сервером как запасным вариантом
          }
        }
        
        // Импортируем менеджер для доступа к mockPythonDiagnostics
        const { languageServerManager } = await import('../main-screen/centerContainer/monaco-lsp-server-manager');
        
        // Вызываем метод для диагностики
        if (languageServerManager) {
          languageServerManager.sendNotification('python', 'textDocument/didOpen', {
            textDocument: {
              uri: filePath,
              languageId: 'python',
              version: 1,
              text: content
            }
          });
          
          // Принудительно запрашиваем диагностику
          languageServerManager.sendNotification('python', 'textDocument/didChange', {
            textDocument: {
              uri: filePath,
              version: 2
            },
            contentChanges: [{ text: content }]
          });
          
          // Обновляем визуальное отображение ошибок в редакторе
          setTimeout(() => {
            if (window.monaco && window.setupErrorDecorations && typeof window.setupErrorDecorations === 'function') {
              const editors = window.monaco.editor.getEditors();
              if (editors && editors.length > 0) {
                console.log(`🎨 Обновление декораций для ${editors.length} редакторов после Python диагностики`);
                editors.forEach((editor: any) => {
                  try {
                    if (window.setupErrorDecorations) {
                      window.setupErrorDecorations(editor);
                    }
                  } catch (err) {
                    console.warn('Ошибка при обновлении декораций:', err);
                  }
                });
              }
            }
          }, 100); // Уменьшаем задержку для быстрого обновления
          
          return 'success';
        } else {
          console.error('Менеджер серверов не доступен');
          return 'error: Менеджер серверов не доступен';
        }
      } catch (error) {
        console.error('Ошибка при обновлении диагностики Python:', error);
        return `error: ${error}`;
      }
    };
    
    // Оставляем только проверку встроенным анализатором без LSP сервера
    setTimeout(async () => {
      try {
        // Регистрируем обработчик для очистки диагностики при закрытии
        window.addEventListener('beforeunload', () => {
          console.log('Очистка ресурсов Python диагностики...');
          clearAllPythonDiagnostics();
        });
        
        // Создаем функцию для принудительного обновления всех Python моделей
        (window as any).updateAllPythonModels = () => {
          try {
            const models = monaco.editor.getModels();
            let pythonModelsCount = 0;
            
            models.forEach((model: monaco.editor.ITextModel) => {
              if (model.getLanguageId() === 'python') {
                pythonModelsCount++;
                
                if (window.registerPythonForModel && typeof window.registerPythonForModel === 'function') {
                  window.registerPythonForModel(model);
                  
                  // Включаем glyphMargin во всех редакторах с Python
                  const editors = monaco.editor.getEditors().filter((editor: any) => 
                    editor.getModel() && editor.getModel().uri.toString() === model.uri.toString()
                  );
                  
                  editors.forEach((editor: any) => {
                    // Устанавливаем опции для правильного отображения глифов
                    editor.updateOptions({ 
                      glyphMargin: true,
                      lineNumbers: 'on',
                      folding: true,
                      minimap: { enabled: true }
                    });
                    
                    // Принудительно обновляем редактор
                    setTimeout(() => {
                      try {
                        // Получаем текущие маркеры для модели
                        const markers = monaco.editor.getModelMarkers({ resource: model.uri });
                        
                        // Только если есть маркеры, создаем декорации
                        if (markers && markers.length > 0) {
                          console.log(`Применяем ${markers.length} декораций напрямую`);
                        
                          // Создаем декорации для ошибок (используя уникальные маркеры)
                          const decorations = Array.from(new Set(markers.map(m => JSON.stringify(m)))).map(key => {
                            const marker = JSON.parse(key);
                            const isError = marker.severity === monaco.MarkerSeverity.Error;
                            
                            return [
                              // Декорация для всей строки (фон)
                              {
                                range: new monaco.Range(
                                  marker.startLineNumber, 
                                  1,
                                  marker.startLineNumber,
                                  model.getLineMaxColumn(marker.startLineNumber)
                                ),
                                options: {
                                  isWholeLine: true,
                                  className: isError ? 'error-line' : 'warning-line',
                                  glyphMarginClassName: isError ? 'error-glyph' : 'warning-glyph',
                                  overviewRuler: {
                                    color: isError ? '#F14C4C' : '#CCA700',
                                    position: monaco.editor.OverviewRulerLane.Right
                                  },
                                  minimap: {
                                    color: isError ? '#F14C4C' : '#CCA700',
                                    position: monaco.editor.MinimapPosition.Inline
                                  },
                                  hoverMessage: { value: marker.message }
                                }
                              },
                              // Декорация для конкретного места ошибки (подчеркивание)
                              {
                                range: new monaco.Range(
                                  marker.startLineNumber,
                                  marker.startColumn,
                                  marker.endLineNumber,
                                  marker.endColumn
                                ),
                                options: {
                                  className: isError ? 'error-text' : 'warning-text',
                                  hoverMessage: { value: marker.message },
                                  stickiness: monaco.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
                                }
                              }
                            ];
                          }).flat();
                          
                          // Применяем декорации
                          const oldDecorations: string[] = [];
                          editor.deltaDecorations(oldDecorations, decorations);
                        }
                        
                        editor.layout();
                        editor.render(true);
                        console.log('✅ Редактор Python полностью обновлен с включенными глифами');
                      } catch (e) {
                        console.warn('Не удалось обновить редактор:', e);
                      }
                    }, 100);
                  });
                }
              }
            });
            
            console.log(`Обновлено ${pythonModelsCount} Python моделей`);
            return pythonModelsCount;
          } catch (err) {
            console.error('Ошибка при обновлении Python моделей:', err);
            return 0;
          }
        };
        
        // Запускаем обновление моделей сразу после полной загрузки
        setTimeout(() => {
          if ((window as any).updateAllPythonModels) {
            (window as any).updateAllPythonModels();
            
            // Запускаем еще раз через 3 секунды для более надежного результата
            setTimeout(() => {
              if ((window as any).updateAllPythonModels) {
                (window as any).updateAllPythonModels();
              }
            }, 3000);
          }
        }, 1000);
      } catch (error) {
        console.error('Ошибка при настройке обработчиков Python диагностики:', error);
      }
    }, 1000);
    
    // Добавляем функцию для принудительного обновления отображения декораций в текущем редакторе
    function setupErrorDecorations(editor: monaco.editor.IStandaloneCodeEditor): void {
      try {
        if (!editor) {
          console.error('setupErrorDecorations: editor is null or undefined');
          return;
        }

        const model = editor.getModel();
        if (!model) {
          console.error('setupErrorDecorations: model is null or undefined');
          return;
        }

        // Настраиваем опции редактора для правильного отображения ошибок
        editor.updateOptions({
          glyphMargin: true,  // Включаем поле для глифов
          lineHeight: 18,     // Фиксированная высота строк
          lineDecorationsWidth: 10,  // Уменьшаем ширину для декораций
          renderLineHighlight: 'none',  // Отключаем подсветку линий
          folding: true,
          fixedOverflowWidgets: true,  // Улучшает поведение всплывающих окон
          scrollBeyondLastLine: false  // Улучшает вертикальное выравнивание
        });

        // Получаем маркеры для модели
        const markers = monaco.editor.getModelMarkers({ resource: model.uri });
        
        // Если нет маркеров, очищаем декорации
        if (!markers || markers.length === 0) {
          editor.deltaDecorations([], []);
          return;
        }

        // Создаем декорации с использованием нашей функции
        const decorations = createDecorations(markers, model);
        
        // Применяем декорации
        const oldDecorations = editor.getDecorationsInRange(
          new monaco.Range(1, 1, model.getLineCount(), model.getLineMaxColumn(model.getLineCount()))
        ) || [];
        
        const oldDecorationIds = oldDecorations
          .filter(d => d.options.className?.includes('error') || d.options.className?.includes('warning'))
          .map(d => d.id);
        
        editor.deltaDecorations(oldDecorationIds, decorations);
        
        // Принудительно перерисовываем редактор для применения изменений
        setTimeout(() => {
          editor.layout();
          editor.render(true);
        }, 10);
  } catch (error) {
        console.error('Error in setupErrorDecorations:', error);
      }
    }
    
    // Инициализируем глобальные переменные
    if (window) {
      window.setupErrorDecorations = setupErrorDecorations;
      window.setupAllErrorDecorations = () => {
        const editors = monaco.editor.getEditors();
        editors.forEach((editor: any) => {
          if (window.setupErrorDecorations) {
            window.setupErrorDecorations(editor);
          }
        });
      };
      window.globalMarkersStore = new Map<string, IPythonMarker[]>();
    }

    // Удалим старые стили и добавим новые, максимально упрощенные
    // Создадим наш упрощенный стиль
    const simpleErrorStyleId = 'monaco-simple-error-styles';
    if (!document.getElementById(simpleErrorStyleId)) {
      const style = document.createElement('style');
      style.id = simpleErrorStyleId;
      style.innerHTML = `
        /* Стили для подчеркивания ошибок без влияния на текст */
        .monaco-editor .error-decoration,
        .monaco-editor .error-text {
          text-decoration: wavy underline #f44336 !important;
          text-decoration-skip-ink: none !important;
          background-color: transparent !important;
          display: inline !important;
          position: relative !important;
          z-index: 1 !important;
          pointer-events: auto !important;
        }
        
        .monaco-editor .warning-decoration,
        .monaco-editor .warning-text {
          text-decoration: wavy underline #ff9800 !important;
          text-decoration-skip-ink: none !important;
          background-color: transparent !important;
          display: inline !important;
          position: relative !important;
          z-index: 1 !important;
          pointer-events: auto !important;
        }
        
        /* Стили для границы ошибок, без изменения размеров текста */
        .monaco-editor .view-overlays .cdr {
          border: none !important;
          background: transparent !important;
          width: auto !important;
          height: auto !important;
          position: static !important;
        }
        
        /* Стили глифов - делаем их тонкими и на полях */
        .monaco-editor .error-glyph,
        .monaco-editor .warning-glyph {
          margin-left: 0 !important;
          width: 3px !important;
          height: 18px !important;
          display: inline-block !important;
          position: absolute !important;
          left: 0 !important;
          top: 0 !important;
          background-color: transparent !important;
          pointer-events: none !important;
        }
        
        .monaco-editor .error-glyph::after {
          content: "";
          display: block;
          width: 3px;
          height: 18px;
          background: #F14C4C;
          border-radius: 1px;
        }
        
        .monaco-editor .warning-glyph::after {
          content: "";
          display: block;
          width: 3px;
          height: 18px;
          background: #CCA700;
          border-radius: 1px;
        }
        
        /* Фиксация размеров и позиционирования линий */
        .monaco-editor .view-line {
          position: relative !important;
          z-index: 0 !important;
          height: 18px !important;
          line-height: 18px !important;
        }
      `;
      document.head.appendChild(style);
    }

    // Функция обновления визуализации ошибок для всех редакторов
    window.forceUpdateAllDecorations = function forceUpdateAllDecorations(): number {
      try {
        let count = 0;
        const editors = monaco.editor.getEditors();
        
        editors.forEach(editor => {
          if (editor && editor.getModel()) {
            if (window.setupErrorDecorations) {
              window.setupErrorDecorations(editor);
              count++;
            }
          }
        });
        
        // Генерируем событие для обновления панели проблем
        window.dispatchEvent(new CustomEvent('markers-updated'));
        window.dispatchEvent(new CustomEvent('python-diagnostics-updated'));
        
        return count;
      } catch (error) {
        console.error('Error in forceUpdateAllDecorations:', error);
        return 0;
      }
    };

    // Добавим интервал для периодического обновления декораций
    // чтобы убедиться, что они правильно отображаются
    setInterval(() => {
      if (window.forceUpdateAllDecorations) {
        window.forceUpdateAllDecorations();
      }
    }, 5000);

    // Добавляем стили для нового типа подчеркивания
    const underlineOnlyStyleId = 'monaco-underline-only-styles';
    if (!document.getElementById(underlineOnlyStyleId)) {
      const style = document.createElement('style');
      style.id = underlineOnlyStyleId;
      style.innerHTML = `
        /* Только подчеркивание без фона для ошибок */
        .monaco-editor .error-underline-only {
          border-bottom: 2px wavy #f44336 !important;
          background-color: transparent !important;
          white-space: pre !important;
          display: inline !important;
          overflow: visible !important;
        }
        
        /* Только подчеркивание без фона для предупреждений */
        .monaco-editor .warning-underline-only {
          border-bottom: 2px wavy #ff9800 !important;
          background-color: transparent !important;
          white-space: pre !important;
          display: inline !important;
          overflow: visible !important;
        }
        
        /* Общие стили для всех строк редактора */
        .monaco-editor .view-line {
          white-space: pre !important;
          overflow: visible !important;
        }
        
        /* Принудительные стили для переноса строк в редакторе */
        .monaco-editor,
        .monaco-editor-background,
        .monaco-editor .inputarea,
        .monaco-editor .view-overlays,
        .monaco-editor .view-lines,
        .monaco-editor .view-line span {
          white-space: pre !important;
          word-wrap: normal !important;
        }
      `;
      document.head.appendChild(style);
    }

    /**
     * Применение унифицированных стилей для ошибок и предупреждений
     */
    function applyUnifiedErrorStyles() {
      try {
        // Добавляем общие стили для ошибок и предупреждений
        if (document.getElementById('monaco-unified-error-styles')) {
          return; // Стили уже добавлены
        }
        
        // Создаем и добавляем элемент стиля
        const style = document.createElement('style');
        style.id = 'monaco-unified-error-styles';
        style.innerHTML = `
          /* Общие стили для всех редакторов с ошибками */
          .monaco-editor .error-line,
          .monaco-editor .warning-line {
            display: inline-block !important;
            white-space: nowrap !important;
            overflow: visible !important;
            height: 18px !important;
            min-height: 18px !important;
            max-height: 18px !important;
            line-height: 18px !important;
            margin: 0 !important;
            padding: 0 !important;
            box-sizing: border-box !important;
          }
          
          .monaco-editor .error-line {
            background-color: rgba(255, 0, 0, 0.03) !important;
          }
          
          .monaco-editor .warning-line {
            background-color: rgba(255, 165, 0, 0.03) !important;
          }
          
          .monaco-editor .error-text,
          .monaco-editor .warning-text {
            white-space: nowrap !important;
            display: inline !important;
            height: 18px !important;
            min-height: 18px !important;
            max-height: 18px !important;
            line-height: 18px !important;
            margin: 0 !important;
            padding: 0 !important;
            box-sizing: border-box !important;
            text-overflow: ellipsis !important;
            overflow: hidden !important;
          }
          
          .monaco-editor .error-text {
            border-bottom: 1px wavy #F14C4C !important;
          }
          
          .monaco-editor .warning-text {
            border-bottom: 1px wavy #CCA700 !important;
          }
          
          /* Унифицированные глифы для ошибок и предупреждений */
          .monaco-editor .error-glyph,
          .monaco-editor .warning-glyph {
            margin-left: 2px !important;
            width: 3px !important;
            height: 12px !important;
            border-radius: 1px !important;
          }
          
          .monaco-editor .error-glyph {
            background: #F14C4C !important;
          }
          
          .monaco-editor .warning-glyph {
            background: #CCA700 !important;
          }
          
          /* Стили для компактных всплывающих подсказок */
          .monaco-hover-content {
            font-size: 11px !important;
            line-height: 1.2 !important;
            max-width: 600px !important;
            padding: 3px 6px !important;
          }
          
          /* Предотвращение переноса строк в редакторе */
          .monaco-editor .view-line {
            display: inline-block !important;
            white-space: nowrap !important;
            overflow: visible !important;
          }
          
          /* Принудительный одинаковый размер для линий в редакторе */
          .monaco-editor .view-lines {
            white-space: nowrap !important;
            overflow: visible !important;
          }
          
          /* Исправление высоты линий с ошибками */
          .monaco-editor .view-overlays .current-line,
          .monaco-editor .margin-view-overlays .current-line-margin {
            height: 18px !important;
            min-height: 18px !important;
            max-height: 18px !important;
          }
        `;
        document.head.appendChild(style);
        console.log('✅ Применены унифицированные стили для ошибок и предупреждений');
        
        // Сразу обновляем все декорации, если доступна функция
        if (window.forceUpdateAllDecorations && typeof window.forceUpdateAllDecorations === 'function') {
          setTimeout(() => {
            window.forceUpdateAllDecorations();
          }, 500);
        }
  } catch (error) {
        console.error('Ошибка при применении унифицированных стилей:', error);
      }
    }

    // Применяем стили при загрузке
    if (typeof document !== 'undefined') {
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        applyUnifiedErrorStyles();
      } else {
        document.addEventListener('DOMContentLoaded', applyUnifiedErrorStyles);
      }
    }

    // Также применяем стили при инициализации Python поддержки
    setTimeout(applyUnifiedErrorStyles, 2000);

    /**
     * Форматирует сообщение об ошибке для более компактного отображения
     * Удаляет лишнюю информацию и делает сообщение более читаемым
     */
    function formatCompactErrorMessage(message: string, filename: string, isError: boolean): string {
      if (!message) return '';
      
      // Очищаем сообщение от лишних деталей
      let cleanMessage = message
        .replace(/Python \[\d+(\.\d+)*\]/g, '')
        .replace(/\(pycodestyle\)/g, '')
        .replace(/\(pylint\)/g, '')
        .replace(/\(mypy\)/g, '')
        .replace(/\(pyflakes\)/g, '')
        .replace(/(^\s+|\s+$)/g, ''); // Удаляем пробелы в начале и конце
      
      // Определяем, является ли это синтаксической ошибкой
      const isSyntaxError = 
        message.includes('SyntaxError') || 
        message.includes('синтаксическая ошибка') ||
        message.includes('недопустимый синтаксис') ||
        message.includes('invalid syntax') ||
        message.includes('expected') ||
        message.includes('ожидалось');
      
      // Добавляем эмодзи для визуального различения типов ошибок
      const icon = isError 
        ? (isSyntaxError ? '⚠️ ' : '❌ ')
        : '⚠️ ';
      
      // Если сообщение слишком длинное, обрезаем его
      const maxLength = 80;
      if (cleanMessage.length > maxLength) {
        cleanMessage = cleanMessage.substring(0, maxLength - 3) + '...';
      }
      
      // Добавляем имя файла и тип ошибки
      const prefix = isError ? 'Ошибка' : 'Предупреждение';
      
      // Если имя файла доступно, добавляем его
      if (filename) {
        return `${icon}${prefix} в ${filename}: ${cleanMessage}`;
      }
      
      return `${icon}${prefix}: ${cleanMessage}`;
    }

    // Глобальная функция для ручного обновления стилей и отображения
    (window as any).updateEditorStyles = function() {
      try {
        console.log('🎨 Принудительное обновление стилей редактора...');
        
        // Применяем унифицированные стили
        applyUnifiedErrorStyles();
        
        // Принудительно впрыскиваем стили непосредственно в DOM
        const styleId = 'monaco-no-line-wrap-force';
        if (!document.getElementById(styleId)) {
          const styleElement = document.createElement('style');
          styleElement.id = styleId;
          styleElement.innerHTML = `
            /* Агрессивное отключение переноса строк */
            .monaco-editor .view-line, 
            .monaco-editor .view-lines,
            .monaco-editor .view-line span,
            .monaco-editor .mtk1,
            .monaco-editor .mtk2,
            .monaco-editor .mtk3,
            .monaco-editor .mtk4,
            .monaco-editor .mtk5,
            .monaco-editor .mtk6,
            .monaco-editor .mtk7,
            .monaco-editor .mtk8,
            .monaco-editor .mtk9 {
              white-space: pre !important;
              display: inline-block !important;
              width: auto !important;
              overflow: visible !important;
            }
            
            /* Принудительно фиксируем высоту всех строк */
            .monaco-editor .view-line {
              height: 18px !important;
              min-height: 18px !important;
              max-height: 18px !important;
              line-height: 18px !important;
            }
            
            /* Убираем перенос для ошибок и предупреждений */
            .error-text, .warning-text,
            .monaco-editor .error-text, 
            .monaco-editor .warning-text,
            .monaco-editor .error-line, 
            .monaco-editor .warning-line {
              white-space: pre !important;
              display: inline-block !important;
              overflow: visible !important;
              height: 18px !important;
              line-height: 18px !important;
            }
          `;
          document.head.appendChild(styleElement);
          console.log('✅ Добавлены принудительные стили для отключения переноса текста');
        }
        
        // Получаем все редакторы
        const editors = window.monaco?.editor.getEditors() || [];
        console.log(`📝 Обновление ${editors.length} редакторов`);
        
        // Модифицируем DOM элементы редактора напрямую
        setTimeout(() => {
          try {
            // Находим все контейнеры строк редактора
            const viewLines = document.querySelectorAll('.monaco-editor .view-lines');
            viewLines.forEach(lines => {
              // Устанавливаем стили для контейнера строк
              const el = lines as HTMLElement;
              el.style.whiteSpace = 'pre';
              el.style.overflowX = 'auto';
              el.style.overflowY = 'hidden';
              
              // Находим и модифицируем все строки внутри
              const viewLineElements = el.querySelectorAll('.view-line');
              viewLineElements.forEach(line => {
                const lineEl = line as HTMLElement;
                lineEl.style.whiteSpace = 'pre';
                lineEl.style.display = 'inline-block';
                lineEl.style.height = '18px';
                lineEl.style.minHeight = '18px';
                lineEl.style.maxHeight = '18px';
                lineEl.style.lineHeight = '18px';
                lineEl.style.overflowX = 'visible';
                lineEl.style.overflowY = 'hidden';
                
                // Модифицируем все элементы span внутри строки
                const spans = lineEl.querySelectorAll('span');
                spans.forEach(span => {
                  const spanEl = span as HTMLElement;
                  spanEl.style.whiteSpace = 'pre';
                  spanEl.style.display = 'inline-block';
                  spanEl.style.overflow = 'visible';
                });
              });
            });
            
            console.log('✅ Стили DOM элементов редактора обновлены');
          } catch (domErr) {
            console.error('Ошибка при прямой модификации DOM:', domErr);
          }
        }, 300);
        
        // Обновляем каждый редактор
        editors.forEach(editor => {
          if (!editor || !editor.getModel) return;
          
          // Настраиваем параметры редактора для предотвращения переноса строк
          editor.updateOptions({
            wordWrap: 'off',
            lineHeight: 18,
            fontLigatures: false,
            glyphMargin: true,
            lineDecorationsWidth: 12,
            wrappingStrategy: 'advanced',
            scrollBeyondLastLine: false,
            renderWhitespace: 'none'
          });
          
          // Принудительно перерисовываем редактор
          setTimeout(() => {
            try {
              // Принудительно вызываем все методы обновления
              editor.layout();
              editor.render(true);
              editor.focus();
              
              // Дополнительные операции для обновления DOM
              const domNode = editor.getDomNode();
              if (domNode) {
                // Добавляем атрибут для CSS селектора
                domNode.setAttribute('data-nowrap', 'true');
              }
            } catch (err) {
              console.warn('Ошибка при обновлении редактора:', err);
            }
          }, 100);
          
          // Обновляем декорации ошибок
          if (window.setupErrorDecorations && typeof window.setupErrorDecorations === 'function') {
            window.setupErrorDecorations(editor);
          }
        });
        
        // Принудительно обновляем все декорации
        if (window.forceUpdateAllDecorations && typeof window.forceUpdateAllDecorations === 'function') {
          window.forceUpdateAllDecorations();
        }
        
        return editors.length;
        } catch (error) {
        console.error('Ошибка при обновлении стилей редактора:', error);
        return 0;
      }
    };
    
    // Вызываем обновление стилей через некоторое время после инициализации
    setTimeout(() => {
      if ((window as any).updateEditorStyles) {
        (window as any).updateEditorStyles();
      }
    }, 2000);

    // Добавим глобальные стили для исправления отображения ошибок в редакторе
    const fixErrorDisplayStyles = () => {
      const styleId = 'monaco-error-fix-display';
      if (!document.getElementById(styleId)) {
        const style = document.createElement('style');
        style.id = styleId;
        style.innerHTML = `
          /* Фиксируем отображение текста, чтобы ошибки не налезали и не смещали позицию */
          .monaco-editor .view-line,
          .monaco-editor .view-lines,
          .monaco-editor .view-line span {
            white-space: pre !important;
            display: inline !important;
          }
          
          /* Линии с ошибками должны оставаться стабильными */
          .monaco-editor .view-overlays .cslr,
          .monaco-editor .view-overlays .cdr {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            position: static !important;
            width: auto !important;
            height: auto !important;
            top: auto !important;
            left: auto !important;
          }
          
          /* Декоративные элементы не должны изменять размеры */
          .monaco-editor .decorationsOverviewRuler,
          .monaco-editor .decorationsOverviewRuler .decoration {
            position: absolute !important;
            right: 0 !important;
            z-index: 0 !important;
            pointer-events: none !important;
          }
          
          /* Улучшаем отображение текста с ошибками */
          .monaco-editor .error-text,
          .monaco-editor .warning-text,
          .monaco-editor .error-decoration,
          .monaco-editor .warning-decoration {
            display: inline !important;
            position: relative !important;
            text-decoration: wavy underline !important;
            text-decoration-skip-ink: none !important;
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            margin: 0 !important;
            padding: 0 !important;
            height: auto !important;
            width: auto !important;
            color: inherit !important;
          }
          
          .monaco-editor .error-text,
          .monaco-editor .error-decoration {
            text-decoration-color: #F14C4C !important;
          }
          
          .monaco-editor .warning-text,
          .monaco-editor .warning-decoration {
            text-decoration-color: #CCA700 !important;
          }
          
          /* Стабилизируем отображение индикаторов маркеров */
          .monaco-editor .margin-view-overlays .cgmr {
            width: 5px !important;
            height: 18px !important;
            margin: 0 !important;
            padding: 0 !important;
          }
        `;
        document.head.appendChild(style);
      }
    };

    // Вызываем функцию для фиксации отображения ошибок
    setTimeout(fixErrorDisplayStyles, 1000);

    // Добавляем обработчик события загрузки страницы для применения стилей
    if (typeof window !== 'undefined') {
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        fixErrorDisplayStyles();
      } else {
        window.addEventListener('DOMContentLoaded', fixErrorDisplayStyles);
      }
      window.addEventListener('load', fixErrorDisplayStyles);
    }

    // Обновляем форматирование ошибок Python, чтобы показывать их более компактно
    window.addEventListener('python-diagnostics-updated', () => {
      setTimeout(fixErrorDisplayStyles, 100);
      
      // Применяем стили ко всем редакторам
      if (window.monaco && window.monaco.editor) {
        const editors = window.monaco.editor.getEditors();
        editors.forEach(editor => {
          if (window.applyNoLineWrap) {
            window.applyNoLineWrap(editor);
          }
        });
      }
    });

    // Добавляем новые CSS стили для предотвращения переноса строк с ошибками
    const noLineWrapErrorStyleId = 'monaco-no-line-wrap-error-styles';
    if (!document.getElementById(noLineWrapErrorStyleId)) {
      const style = document.createElement('style');
      style.id = noLineWrapErrorStyleId;
      style.innerHTML = `
        /* Принудительно блокируем перенос строк с ошибками */
        .monaco-editor .view-line,
        .monaco-editor .view-lines {
          white-space: pre !important;
          overflow-x: visible !important;
          overflow-y: hidden !important;
          word-wrap: normal !important;
          word-break: normal !important;
          text-overflow: clip !important;
          height: 18px !important;
          line-height: 18px !important;
          user-select: text !important;
          position: relative !important;
          width: auto !important;
          min-width: auto !important;
          max-width: none !important;
        }
        
        /* Устанавливаем строгий формат для текста в редакторе */
        .monaco-editor .mtk1,
        .monaco-editor .mtk2,
        .monaco-editor .mtk3,
        .monaco-editor .mtk4,
        .monaco-editor .mtk5,
        .monaco-editor .mtk6,
        .monaco-editor .mtk7,
        .monaco-editor .mtk8,
        .monaco-editor .mtk9,
        .monaco-editor span {
          display: inline !important;
          white-space: pre !important;
          overflow: visible !important;
          text-overflow: clip !important;
          height: 18px !important;
          line-height: 18px !important;
          position: static !important;
        }
        
        /* Стиль подсветки ошибок */
        .monaco-editor .error-text,
        .monaco-editor .warning-text {
          text-decoration: wavy underline !important;
          text-decoration-skip-ink: none !important;
          border-bottom: none !important;
          background: transparent !important;
          height: 18px !important;
          line-height: 18px !important;
          position: relative !important;
          display: inline !important;
          white-space: pre !important;
          overflow: visible !important;
          text-overflow: clip !important;
          padding: 0 !important;
          margin: 0 !important;
        }
        
        .monaco-editor .error-text {
          text-decoration-color: #FF4C4C !important;
        }
        
        .monaco-editor .warning-text {
          text-decoration-color: #FFCC00 !important;
        }
        
        /* Стили для маркеров на левом поле */
        .monaco-editor .margin-view-overlays .cgmr {
          height: 18px !important;
          line-height: 18px !important;
          width: 4px !important;
          position: absolute !important;
          left: 1px !important;
        }
        
        /* Корректировка контейнера редактора */
        .monaco-editor .overflow-guard,
        .monaco-editor .monaco-scrollable-element {
          overflow-x: auto !important;
          overflow-y: auto !important;
        }
        
        .monaco-editor .view-overlays .cdr,
        .monaco-editor .view-overlays .cslr {
          border: none !important;
          background: transparent !important;
          position: static !important;
          width: auto !important;
          height: 18px !important;
          top: auto !important;
          left: auto !important;
        }
      `;
      document.head.appendChild(style);
    }

    /**
     * Обновленная функция для применения стилей к редактору, предотвращающих перенос строк с ошибками
     */
    window.applyNoLineWrap = function applyNoLineWrap(editor) {
      try {
        if (!editor) return;
        
        // Отключаем перенос строк и устанавливаем фиксированную высоту строк
        editor.updateOptions({
          wordWrap: 'off',
          lineHeight: 18,
          lineDecorationsWidth: 12,
          glyphMargin: true,
          overviewRulerBorder: false,
          scrollBeyondLastLine: false,
          renderWhitespace: 'none',
          renderControlCharacters: false,
          wrappingStrategy: 'simple',
          automaticLayout: true,
          renderLineHighlight: 'none'
        });
        
        // Принудительное обновление редактора
        setTimeout(() => {
          try {
            // Обновляем размер и перерисовываем редактор
            editor.layout();
            editor.render(true);
            
            // Находим и модифицируем DOM элементы редактора напрямую
            const editorDom = editor.getDomNode();
            if (editorDom) {
              // Находим контейнер с линиями текста
              const viewLines = editorDom.querySelector('.view-lines');
              if (viewLines) {
                // Устанавливаем CSS свойства напрямую
                viewLines.setAttribute('style', 
                  'white-space: pre !important; ' +
                  'overflow-x: visible !important; ' +
                  'overflow-y: hidden !important; ' +
                  'word-wrap: normal !important; ' +
                  'word-break: normal !important;'
                );
                
                // Находим все строки и устанавливаем им фиксированную высоту
                const lines = viewLines.querySelectorAll('.view-line');
                lines.forEach(line => {
                  line.setAttribute('style',
                    'white-space: pre !important; ' + 
                    'height: 18px !important; ' +
                    'line-height: 18px !important; ' +
                    'overflow: visible !important; ' +
                    'position: relative !important;'
                  );
                });
              }
            }
          } catch (err) {
            console.warn('Ошибка при прямом обновлении DOM редактора:', err);
          }
        }, 10);
        } catch (error) {
        console.error('Ошибка в applyNoLineWrap:', error);
      }
    };

    // Применяем стили ко всем редакторам при инициализации
    setTimeout(() => {
      try {
        if (window.monaco && window.monaco.editor) {
          const editors = window.monaco.editor.getEditors();
          editors.forEach(editor => {
            if (window.applyNoLineWrap) {
              window.applyNoLineWrap(editor);
            }
          });
        }
      } catch (err) {
        console.warn('Ошибка при применении стилей ко всем редакторам:', err);
      }
    }, 500);

    // Добавляем обработчик для применения стилей при открытии нового редактора
    monaco.editor.onDidCreateEditor(editor => {
      if (window.applyNoLineWrap) {
        window.applyNoLineWrap(editor);
      }
    });

    // Добавляем обработчик события для применения стилей при обновлении диагностики
    window.addEventListener('python-diagnostics-updated', () => {
      setTimeout(() => {
        try {
          if (window.monaco && window.monaco.editor) {
            const editors = window.monaco.editor.getEditors();
            editors.forEach(editor => {
              if (window.applyNoLineWrap) {
                window.applyNoLineWrap(editor);
              }
            });
          }
        } catch (err) {
          console.warn('Ошибка при обновлении стилей после диагностики:', err);
        }
      }, 50);
    });

    // Создаем стили для строгого контроля высоты строк и предотвращения переносов
    const strictErrorStyleId = 'monaco-strict-line-height-styles';
    if (!document.getElementById(strictErrorStyleId)) {
      const style = document.createElement('style');
      style.id = strictErrorStyleId;
      style.innerHTML = `
        /* Фиксируем линии редактора с абсолютной жесткостью */
        .monaco-editor,
        .monaco-editor-background,
        .monaco-editor .inputarea.ime-input {
          word-wrap: normal !important;
          white-space: pre !important;
        }
        
        /* Строки всегда имеют фиксированную высоту и не переносятся */
        .monaco-editor .view-line,
        .monaco-editor .view-lines,
        .monaco-editor .view-line span {
          display: inline-block !important;
          white-space: pre !important;
          word-wrap: normal !important;
          overflow-x: visible !important;
          overflow-y: hidden !important;
          height: 18px !important;
          min-height: 18px !important;
          max-height: 18px !important;
          line-height: 18px !important;
        }
        
        /* Текстовые элементы не должны менять свою форму */
        .monaco-editor .mtk1, .monaco-editor .mtk2, .monaco-editor .mtk3,
        .monaco-editor .mtk4, .monaco-editor .mtk5, .monaco-editor .mtk6,
        .monaco-editor .mtk7, .monaco-editor .mtk8, .monaco-editor .mtk9 {
          display: inline-block !important;
          white-space: pre !important;
          word-wrap: normal !important;
        }
        
        /* Ошибки должны просто подчеркивать текст без изменения его положения */
        .monaco-editor .cdr,
        .monaco-editor .cslr,
        .monaco-editor .detected-link,
        .monaco-editor .selected-text {
          border: none !important;
          background: transparent !important;
          position: static !important;
          display: inline !important;
        }
        
        /* Контейнер для текстовых строк должен скроллиться по горизонтали */
        .monaco-scrollable-element {
          overflow-x: auto !important;
          overflow-y: auto !important;
        }
        
        /* Стили строк с ошибками - только нижнее подчеркивание */
        .monaco-editor .error-text,
        .monaco-editor .warning-text {
          border-bottom: 2px wavy !important;
          text-decoration: none !important;
          background: transparent !important;
          display: inline !important;
          position: static !important;
        }
        
        .monaco-editor .error-text {
          border-bottom-color: #FF4C4C !important;
        }
        
        .monaco-editor .warning-text {
          border-bottom-color: #FFCC00 !important;
        }
      `;
      document.head.appendChild(style);
    }

    // Добавляем обработчик для принудительного обновления стилей при изменении размеров редактора
    window.addEventListener('resize', () => {
      setTimeout(() => {
        if (window.monaco && window.monaco.editor) {
          const editors = window.monaco.editor.getEditors();
          editors.forEach(editor => {
            try {
              editor.layout();
              
              // Принудительно устанавливаем режим без переноса строк
              editor.updateOptions({
                wordWrap: 'off',
                lineHeight: 18,
                renderLineHighlight: 'none',
                automaticLayout: true
              });
            } catch (err) {
              console.warn('Ошибка при обновлении редактора после изменения размера:', err);
            }
          });
        }
      }, 100);
    });

    /**
     * Применяет все необходимые стили для правильного отображения ошибок без переноса строк
     */
    function applyAllErrorStyles() {
      // Добавляем CSS стили для исправления отображения ошибок
      const fixDisplayErrorStyles = document.createElement('style');
      fixDisplayErrorStyles.id = 'monaco-fix-error-display-styles';
      fixDisplayErrorStyles.innerHTML = `
        /* Принудительно запрещаем переносы строк во всех элементах редактора */
        .monaco-editor,
        .monaco-editor-background,
        .monaco-editor .view-lines,
        .monaco-editor .view-line,
        .monaco-editor .view-line span,
        .monaco-editor .lines-content,
        .monaco-editor .monaco-editor-background {
          white-space: pre !important;
          word-wrap: normal !important;
          overflow-wrap: normal !important;
          word-break: normal !important;
          user-select: text !important;
          display: block !important;
        }
        
        /* Фиксируем высоту строк */
        .monaco-editor .view-line {
          height: 18px !important;
          min-height: 18px !important;
          max-height: 18px !important;
          line-height: 18px !important;
          position: relative !important;
          overflow-x: visible !important;
          overflow-y: hidden !important;
        }
        
        /* Текстовые токены не переносятся */
        .monaco-editor .view-line span,
        .monaco-editor span {
          white-space: pre !important;
          display: inline-block !important;
          height: 18px !important;
          line-height: 18px !important;
        }
        
        /* Глифы ошибок и предупреждений имеют нормальную высоту */
        .monaco-editor .margin-view-overlays .cgmr {
          height: 18px !important;
          position: relative !important;
        }
        
        /* Вместо заливки фона используем только подчеркивание */
        .monaco-editor .error-text,
        .monaco-editor .warning-text {
          text-decoration: wavy underline !important;
          text-decoration-skip-ink: none !important;
          border: none !important;
          background: transparent !important;
          display: inline !important;
          white-space: pre !important;
        }
        
        .monaco-editor .error-text {
          text-decoration-color: #F14C4C !important;
        }
        
        .monaco-editor .warning-text {
          text-decoration-color: #CCA700 !important;
        }
        
        /* Убираем все рамки и цветные фоны */
        .monaco-editor .cdr,
        .monaco-editor .cslr {
          border: none !important;
          background: transparent !important;
        }
      `;
      
      // Проверяем, нет ли уже такого стиля
      if (!document.getElementById('monaco-fix-error-display-styles')) {
        document.head.appendChild(fixDisplayErrorStyles);
      }
      
      // Применяем стили ко всем редакторам
      if (window.monaco && window.monaco.editor) {
        const editors = window.monaco.editor.getEditors();
        editors.forEach(editor => {
          if (editor) {
            // Настраиваем опции редактора для предотвращения переноса строк
            editor.updateOptions({
              wordWrap: 'off',
              lineHeight: 18,
              glyphMargin: true,
              scrollBeyondLastLine: false,
              renderLineHighlight: 'none',
              folding: false
            });
            
            // Принудительно перерисовываем редактор
            try {
              editor.layout();
              editor.render(true);
            } catch (err) {
              console.warn('Ошибка при принудительной перерисовке редактора:', err);
            }
          }
        });
      }
    }

    // Вызываем функцию применения стилей при загрузке
    if (typeof document !== 'undefined') {
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(applyAllErrorStyles, 500);
      } else {
        document.addEventListener('DOMContentLoaded', () => setTimeout(applyAllErrorStyles, 500));
      }
      document.addEventListener('load', () => setTimeout(applyAllErrorStyles, 500));
    }

    // При обновлении диагностики применяем стили снова
    window.addEventListener('python-diagnostics-updated', () => {
      setTimeout(applyAllErrorStyles, 100);
    });

    // При изменении размера окна также применяем стили
    window.addEventListener('resize', () => {
      setTimeout(applyAllErrorStyles, 100);
    });

    /**
     * Создает декорации для маркеров, размещая их НАД текстом
     */
    function createNonInvasiveDecorations(markers, model) {
      if (!markers || !Array.isArray(markers) || markers.length === 0) return [];
      
      return markers.map(marker => {
        if (!marker) return null;
        
        const isError = marker.severity === monaco.MarkerSeverity.Error;
        const lineNumber = marker.startLineNumber || 1;
        
        // Создаем декорацию, которая отображается НАД текстом
        return {
          range: new monaco.Range(
            lineNumber, 1,
            lineNumber, 1
          ),
          options: {
            isWholeLine: true,
            className: isError ? 'error-line-above' : 'warning-line-above',
            glyphMarginClassName: isError ? 'error-glyph' : 'warning-glyph',
            overviewRuler: {
              color: isError ? '#FF4C4C' : '#FFCC00',
              position: monaco.editor.OverviewRulerLane.Right
            },
            minimap: {
              color: isError ? '#FF4C4C' : '#FFCC00',
              position: monaco.editor.MinimapPosition.Inline
            },
            stickiness: monaco.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
          }
        };
      }).filter(Boolean);
    }

    /**
     * Обновляет отображение ошибок, размещая их НАД текстом
     */
    function setupNonInvasiveErrorDecorations(editor) {
      try {
        if (!editor) return;
        
        const model = editor.getModel();
        if (!model) return;
        
        // Настраиваем опции редактора
        editor.updateOptions({
          glyphMargin: true,
          lineHeight: 18,
          lineDecorationsWidth: 10
        });
        
        // Получаем маркеры для текущей модели
        const markers = monaco.editor.getModelMarkers({ resource: model.uri });
        if (!markers || markers.length === 0) {
          // Очищаем все декорации, если ошибок нет
          editor.deltaDecorations(
            editor.getModel()?.getAllDecorations().map(d => d.id) || [], 
            []
          );
          return;
        }
        
        // Создаем декорации, которые не конфликтуют с текстом
        const decorations = createNonInvasiveDecorations(markers, model);
        
        // Применяем новые декорации, заменяя старые
        const oldDecorations = editor.getModel()?.getAllDecorations() || [];
        const oldDecorationIds = oldDecorations
          .filter(d => 
            d.options.className === 'error-line-above' || 
            d.options.className === 'warning-line-above'
          )
          .map(d => d.id);
        
        editor.deltaDecorations(oldDecorationIds, decorations);
        
        // Добавляем подсказки при наведении
        markers.forEach(marker => {
          if (!model) return;
          
          const lineContent = model.getLineContent(marker.startLineNumber);
          const hoverMessage = {
            value: marker.message,
            isTrusted: true
          };
          
          // Создаем подсказку для отображения текста ошибки при наведении
          monaco.editor.createDecorationsCollection([{
            range: new monaco.Range(
              marker.startLineNumber, 
              marker.startColumn, 
              marker.endLineNumber,
              marker.endColumn
            ),
            options: {
              hoverMessage: hoverMessage
            }
          }]);
        });
        } catch (error) {
        console.error('Ошибка при настройке декораций:', error);
      }
    }

    // Добавляем глобальные CSS стили для отображения ошибок над текстом
    const aboveTextErrorStyleId = 'monaco-above-text-error-styles';
    if (!document.getElementById(aboveTextErrorStyleId)) {
      const style = document.createElement('style');
      style.id = aboveTextErrorStyleId;
      style.innerHTML = `
        /* Тонкая полоса над строкой с ошибкой */
        .monaco-editor .error-line-above {
          border-top: 2px solid #FF4C4C !important;
          background: transparent !important;
          margin-top: -2px !important;
          z-index: 100 !important;
          pointer-events: none !important;
        }
        
        .monaco-editor .warning-line-above {
          border-top: 2px solid #FFCC00 !important;
          background: transparent !important;
          margin-top: -2px !important;
          z-index: 100 !important;
          pointer-events: none !important;
        }
        
        /* Глифы на полях - маленькие квадраты */
        .monaco-editor .error-glyph {
          background-color: #FF4C4C !important;
          width: 4px !important;
          height: 18px !important;
          margin-left: 2px !important;
          z-index: 100 !important;
        }
        
        .monaco-editor .warning-glyph {
          background-color: #FFCC00 !important;
          width: 4px !important;
          height: 18px !important;
          margin-left: 2px !important;
          z-index: 100 !important;
        }
        
        /* Убираем все фоновые подсветки и подчеркивания */
        .monaco-editor .cdr,
        .monaco-editor .cslr,
        .monaco-editor .squiggly-error,
        .monaco-editor .squiggly-warning,
        .monaco-editor .error-text,
        .monaco-editor .warning-text {
          background: transparent !important;
          border: none !important;
          text-decoration: none !important;
          border-bottom: none !important;
        }
        
        /* Фиксируем высоту строк */
        .monaco-editor .view-line {
          position: relative !important;
          height: 18px !important;
          line-height: 18px !important;
          white-space: pre !important;
          overflow-x: visible !important;
          overflow-y: hidden !important;
        }
      `;
      document.head.appendChild(style);
    }

    // Обновляем функцию для применения новых декораций
    window.setupErrorDecorations = setupNonInvasiveErrorDecorations;

    // Обновляем функцию, вызываемую для всех редакторов
    window.setupAllErrorDecorations = () => {
      if (window.monaco && window.monaco.editor) {
        const editors = window.monaco.editor.getEditors();
        editors.forEach(editor => {
          if (window.setupErrorDecorations) {
            window.setupErrorDecorations(editor);
          }
        });
      }
    };

    // Обновляем функцию для форсирования обновления всех декораций
    window.forceUpdateAllDecorations = () => {
      try {
        if (window.monaco && window.monaco.editor) {
          const editors = window.monaco.editor.getEditors();
          let count = 0;
          
          editors.forEach(editor => {
            if (window.setupErrorDecorations) {
              window.setupErrorDecorations(editor);
              count++;
            }
          });
          
          return count;
        }
        return 0;
      } catch (error) {
        console.error('Ошибка при обновлении декораций:', error);
        return 0;
      }
    };

    // Добавляем обработчик для обновления декораций при изменении диагностики
    window.addEventListener('python-diagnostics-updated', () => {
      setTimeout(() => {
        if (window.forceUpdateAllDecorations) {
          window.forceUpdateAllDecorations();
        }
      }, 100);
    });

    // Применяем новые стили для отображения ошибок при загрузке страницы
    function applyErrorStylesOnLoad() {
      // Проверяем, есть ли редакторы для применения стилей
      if (window.monaco && window.monaco.editor) {
        // Применяем наши декорации ко всем редакторам
        if (window.forceUpdateAllDecorations) {
          window.forceUpdateAllDecorations();
        }
        
        // Применяем стили ко всем новым редакторам
        monaco.editor.onDidCreateEditor(editor => {
          setTimeout(() => {
            if (window.setupErrorDecorations) {
              window.setupErrorDecorations(editor);
            }
          }, 100);
        });
      }
    }

    // Запускаем применение стилей при загрузке
    if (typeof document !== 'undefined') {
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(applyErrorStylesOnLoad, 500);
      } else {
        document.addEventListener('DOMContentLoaded', () => {
          setTimeout(applyErrorStylesOnLoad, 500);
        });
      }
      
      // Также запускаем при полной загрузке
      window.addEventListener('load', () => {
        setTimeout(applyErrorStylesOnLoad, 1000);
      });
    }

    /**
     * Создает минималистичные декорации, которые не перекрывают текст
     */
    function createMinimalisticErrorDecorations(markers, model) {
      if (!markers || markers.length === 0) return [];
      
      const decorations = [];
      
      markers.forEach(marker => {
        // Тип ошибки
        const isError = marker.severity === monaco.MarkerSeverity.Error;
        
        // 1. Добавляем декорацию на поле слева (marginDecoration)
        decorations.push({
          range: new monaco.Range(
            marker.startLineNumber, 1,
            marker.startLineNumber, 1
          ),
          options: {
            glyphMarginClassName: isError ? 'minimal-error-glyph' : 'minimal-warning-glyph',
            stickiness: monaco.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
          }
        });
        
        // 2. Добавляем тонкую линию на полосе прокрутки (overviewRuler)
        decorations.push({
          range: new monaco.Range(
            marker.startLineNumber, 1,
            marker.startLineNumber, model.getLineMaxColumn(marker.startLineNumber)
          ),
          options: {
            overviewRuler: {
              color: isError ? '#FF4C4C' : '#FFCC00',
              position: monaco.editor.OverviewRulerLane.Right
            },
            stickiness: monaco.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
          }
        });
        
        // 3. Добавляем подсказку при наведении (hoverMessage)
        decorations.push({
          range: new monaco.Range(
            marker.startLineNumber, marker.startColumn,
            marker.endLineNumber, marker.endColumn
          ),
          options: {
            hoverMessage: {
              value: marker.message,
              isTrusted: true
            },
            inlineClassName: 'minimal-error-hint',
            stickiness: monaco.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
          }
        });
      });
      
      return decorations;
    }

    /**
     * Применяет минималистичные декорации к редактору
     */
    function applyMinimalisticErrorDecorations(editor) {
      if (!editor) return;
      
      const model = editor.getModel();
      if (!model) return;
      
      // Настраиваем опции редактора
      editor.updateOptions({
        glyphMargin: true,
        lineHeight: 18,
        lineDecorationsWidth: 10
      });
      
      // Получаем маркеры
      const markers = monaco.editor.getModelMarkers({ resource: model.uri });
      
      // Очищаем существующие декорации
      const oldDecorations = editor.getModel()?.getAllDecorations() || [];
      const oldDecorationIds = oldDecorations
        .filter(d => {
          const className = d.options?.className || '';
          const glyphClassName = d.options?.glyphMarginClassName || '';
          return className.includes('error') || 
                 className.includes('warning') ||
                 glyphClassName.includes('error') ||
                 glyphClassName.includes('warning');
        })
        .map(d => d.id);
      
      // Если нет ошибок, просто очищаем декорации
      if (!markers || markers.length === 0) {
        editor.deltaDecorations(oldDecorationIds, []);
        return;
      }
      
      // Создаем и применяем новые декорации
      const decorations = createMinimalisticErrorDecorations(markers, model);
      editor.deltaDecorations(oldDecorationIds, decorations);
    }

    // Добавляем стили для минималистичных декораций
    const minimalisticErrorStyleId = 'monaco-minimalistic-error-styles';
    if (!document.getElementById(minimalisticErrorStyleId)) {
      const style = document.createElement('style');
      style.id = minimalisticErrorStyleId;
      style.innerHTML = `
        /* Минималистичные маркеры на полях - тонкие линии */
        .monaco-editor .minimal-error-glyph {
          margin-left: 5px;
          width: 3px !important;
          background-color: #FF4C4C;
          height: 18px !important;
        }
        
        .monaco-editor .minimal-warning-glyph {
          margin-left: 5px;
          width: 3px !important;
          background-color: #FFCC00;
          height: 18px !important;
        }
        
        /* Убираем все стандартные декорации ошибок */
        .monaco-editor .squiggly-error,
        .monaco-editor .squiggly-warning,
        .monaco-editor .error-text,
        .monaco-editor .warning-text,
        .monaco-editor .error-line-above,
        .monaco-editor .warning-line-above,
        .monaco-editor .error-decoration,
        .monaco-editor .warning-decoration {
          background: transparent !important;
          border: none !important;
          text-decoration: none !important;
        }
        
        /* Убираем все цветные фоны, которые могут влиять на текст */
        .monaco-editor .cdr,
        .monaco-editor .cslr,
        .monaco-editor .detected-link,
        .monaco-editor .selected-text {
          background: transparent !important;
          border: none !important;
        }
        
        /* Фиксируем высоту строк */
        .monaco-editor .view-line {
          height: 18px !important;
          line-height: 18px !important;
          white-space: pre !important;
        }
      `;
      document.head.appendChild(style);
    }

    // Обновляем глобальную функцию для использования минималистичных декораций
    window.setupErrorDecorations = applyMinimalisticErrorDecorations;

    // Обновляем функцию для применения декораций ко всем редакторам
    window.setupAllErrorDecorations = () => {
      if (window.monaco && window.monaco.editor) {
        const editors = window.monaco.editor.getEditors();
        editors.forEach(editor => {
          if (window.setupErrorDecorations) {
            window.setupErrorDecorations(editor);
          }
        });
      }
    };

    // Обновляем функцию для форсирования обновления декораций
    window.forceUpdateAllDecorations = () => {
      try {
        if (window.monaco && window.monaco.editor) {
          const editors = window.monaco.editor.getEditors();
          editors.forEach(editor => {
            if (window.setupErrorDecorations) {
              window.setupErrorDecorations(editor);
            }
          });
        }
  } catch (error) {
        console.error('Ошибка при обновлении декораций:', error);
      }
    };

    // Обновляем при загрузке страницы
    if (typeof document !== 'undefined') {
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(window.forceUpdateAllDecorations, 500);
      } else {
        document.addEventListener('DOMContentLoaded', () => {
          setTimeout(window.forceUpdateAllDecorations, 500);
        });
      }
      
      window.addEventListener('load', () => {
        setTimeout(window.forceUpdateAllDecorations, 1000);
      });
    }

    // Обработчик для новых редакторов
    monaco.editor.onDidCreateEditor(editor => {
      setTimeout(() => {
        if (window.setupErrorDecorations) {
          window.setupErrorDecorations(editor);
        }
      }, 100);
    });

    // Обработчик события обновления диагностики
    window.addEventListener('python-diagnostics-updated', () => {
      setTimeout(window.forceUpdateAllDecorations, 100);
    });

    /**
     * Ультра-минималистичные декорации, которые совсем не трогают текст
     */
    function ultraMinimalDecorations(editor) {
      if (!editor || !editor.getModel) return;
      
      const model = editor.getModel();
      if (!model) return;
      
      // Сначала очищаем все декорации
      const existingDecorations = editor.getModel().getAllDecorations();
      const oldIds = existingDecorations
        .filter(d => d.options.glyphMarginClassName || 
                    d.options.overviewRulerColor ||
                    d.options.className && 
                    (d.options.className.includes('error') || 
                     d.options.className.includes('warning')))
        .map(d => d.id);
      
      // Получаем все маркеры для модели
      const markers = monaco.editor.getModelMarkers({ resource: model.uri });
      if (!markers || markers.length === 0) {
        // Если маркеров нет, просто очищаем декорации
        editor.deltaDecorations(oldIds, []);
        return;
      }
      
      // Создаем новые декорации для маркеров
      const newDecorations = [];
      
      // Удаляем старые декорации с текста
      editor.deltaDecorations(oldIds, []);
      
      // Для каждого маркера создаем только маркер на поле и в полосе прокрутки
      markers.forEach(marker => {
        const isError = marker.severity === monaco.MarkerSeverity.Error;
        
        // Добавляем маркер только на поле слева
        newDecorations.push({
          range: new monaco.Range(
            marker.startLineNumber, 1,
            marker.startLineNumber, 1
          ),
          options: {
            isWholeLine: false,
            glyphMarginClassName: isError ? 'ultra-minimal-error' : 'ultra-minimal-warning',
            overviewRuler: {
              color: isError ? '#FF4C4C80' : '#FFCC0080',
              position: monaco.editor.OverviewRulerLane.Right
            },
            minimap: {
              color: isError ? '#FF4C4C' : '#FFCC00',
              position: monaco.editor.MinimapPosition.Inline
            },
            hoverMessage: { value: marker.message }
          }
        });
      });
      
      // Применяем только новые минималистичные декорации
      editor.deltaDecorations([], newDecorations);

      // Устанавливаем опции редактора
      editor.updateOptions({
        lineHeight: 18,
        glyphMargin: true,
        lineDecorationsWidth: 10,
        lineNumbers: 'on',
        renderWhitespace: 'none',
        wordWrap: 'off'
      });
    }

    // Добавляем CSS стили для ультра-минималистичных декораций
    const ultraMinimalStyleId = 'monaco-ultra-minimal-error-styles';
    if (!document.getElementById(ultraMinimalStyleId)) {
      const style = document.createElement('style');
      style.id = ultraMinimalStyleId;
      style.innerHTML = `
        /* Очистка всех предыдущих стилей ошибок */
        .monaco-editor .squiggly-error,
        .monaco-editor .squiggly-warning,
        .monaco-editor .squiggly-info,
        .monaco-editor .error-text,
        .monaco-editor .warning-text,
        .monaco-editor .error-decoration,
        .monaco-editor .warning-decoration,
        .monaco-editor .error-line-above,
        .monaco-editor .warning-line-above,
        .monaco-editor span[class*="error"],
        .monaco-editor span[class*="warning"],
        .monaco-editor .cdr,
        .monaco-editor .cslr {
          background: transparent !important;
          border: none !important;
          border-bottom: none !important;
          border-top: none !important;
          text-decoration: none !important;
          color: inherit !important;
        }
        
        /* Ультра-минималистичный маркер на полях - тонкая вертикальная линия */
        .monaco-editor .ultra-minimal-error {
          border-left: 3px solid #FF4C4C !important;
          width: 0 !important;
          height: 18px !important;
          margin-left: 4px !important;
        }
        
        .monaco-editor .ultra-minimal-warning {
          border-left: 3px solid #FFCC00 !important;
          width: 0 !important;
          height: 18px !important;
          margin-left: 4px !important;
        }
        
        /* Принудительно отключаем стили, которые могут влиять на текст */
        .monaco-editor .view-overlays,
        .monaco-editor .view-zones,
        .monaco-editor .margin-view-overlays {
          pointer-events: none !important;
        }
        
        /* Отключаем слои маркеров, которые могут влиять на текст */
        .monaco-editor .lines-decorations,
        .monaco-editor .lines-content,
        .monaco-editor .view-lines {
          z-index: 0 !important;
          position: relative !important;
        }
        
        /* Принудительно отключаем всплывающие подсказки при наведении */
        .monaco-editor .monaco-hover { 
          z-index: 50 !important;
          position: absolute !important;
          top: auto !important;
          left: auto !important;
        }
      `;
      document.head.appendChild(style);
    }

    // Переопределяем глобальные функции для использования новых ультра-минималистичных декораций
    window.setupErrorDecorations = ultraMinimalDecorations;

    // Обновляем функцию для всех редакторов
    window.setupAllErrorDecorations = () => {
      if (window.monaco && window.monaco.editor) {
        const editors = window.monaco.editor.getEditors();
        editors.forEach(editor => {
          ultraMinimalDecorations(editor);
        });
      }
    };

    // Обновляем функцию для форсирования обновления
    window.forceUpdateAllDecorations = () => {
      try {
        if (window.monaco && window.monaco.editor) {
          const editors = window.monaco.editor.getEditors();
          editors.forEach(editor => {
            ultraMinimalDecorations(editor);
          });
        }
      } catch (error) {
        console.error('Ошибка при обновлении декораций:', error);
      }
    };

    // Применяем ультра-минималистичные декорации ко всем редакторам при загрузке
    if (typeof document !== 'undefined') {
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(() => { 
          if (window.forceUpdateAllDecorations) {
            window.forceUpdateAllDecorations();
          }
        }, 500);
      } else {
        document.addEventListener('DOMContentLoaded', () => {
          setTimeout(() => {
            if (window.forceUpdateAllDecorations) {
              window.forceUpdateAllDecorations();
            }
          }, 500);
        });
      }
      
      window.addEventListener('load', () => {
        setTimeout(() => {
          if (window.forceUpdateAllDecorations) {
            window.forceUpdateAllDecorations();
          }
        }, 1000);
      });
    }

    // Обработчик для новых редакторов
    monaco.editor.onDidCreateEditor(editor => {
      setTimeout(() => {
        ultraMinimalDecorations(editor);
      }, 100);
    });

    // Обработчик события обновления диагностики
    window.addEventListener('python-diagnostics-updated', () => {
      setTimeout(() => {
        if (window.forceUpdateAllDecorations) {
          window.forceUpdateAllDecorations();
        }
      }, 100);
    });

    // Добавляем обработчик для принудительного очищения всех декораций при изменении контента
    monaco.editor.onDidChangeModelContent(event => {
      const model = event.model;
      if (model) {
        const uri = model.uri.toString();
        // Отложенное обновление декораций после изменения контента
        setTimeout(() => {
          const editors = monaco.editor.getEditors();
          editors.forEach(editor => {
            if (editor.getModel()?.uri.toString() === uri) {
              ultraMinimalDecorations(editor);
            }
          });
        }, 500);
      }
    });

    // Блокируем любые стандартные декорации ошибок
    const preventStandardDecorations = () => {
      // Переопределяем метод setModelMarkers, чтобы убрать стандартные декорации
      const originalSetModelMarkers = monaco.editor.setModelMarkers;
      monaco.editor.setModelMarkers = (model, owner, markers) => {
        // Вызываем оригинальный метод для установки маркеров
        originalSetModelMarkers(model, owner, markers);
        
        // При добавлении маркеров сразу обновляем все редакторы с этой моделью
        setTimeout(() => {
          const editors = monaco.editor.getEditors();
          editors.forEach(editor => {
            if (editor.getModel() === model) {
              ultraMinimalDecorations(editor);
            }
          });
        }, 0);
      };
    };

    // Вызываем функцию блокировки стандартных декораций
    preventStandardDecorations();

    /**
     * Функция для применения тонких подчеркиваний вместо полос
     */
    function applyThinUnderlineDecorations(editor) {
      if (!editor || !editor.getModel) return;
      
      const model = editor.getModel();
      if (!model) return;
      
      // Очищаем существующие декорации
      const allDecorations = editor.getModel().getAllDecorations();
      const ids = allDecorations.map(d => d.id);
      editor.deltaDecorations(ids, []);
      
      // Получаем маркеры
      const markers = monaco.editor.getModelMarkers({ resource: model.uri });
      if (!markers || markers.length === 0) return;
      
      // Создаем новые декорации только с подчеркиванием
      const decorations = markers.map(marker => ({
        range: new monaco.Range(
          marker.startLineNumber,
          marker.startColumn,
          marker.endLineNumber,
          marker.endColumn
        ),
        options: {
          inlineClassName: marker.severity === monaco.MarkerSeverity.Error ? 
                           'thin-error-underline' : 'thin-warning-underline',
          hoverMessage: { value: marker.message },
          minimap: {
            color: marker.severity === monaco.MarkerSeverity.Error ? 
                   '#FF4C4C' : '#FFCC00',
            position: monaco.editor.MinimapPosition.Inline
          },
          overviewRuler: {
            color: marker.severity === monaco.MarkerSeverity.Error ? 
                   '#FF4C4C' : '#FFCC00',
            position: monaco.editor.OverviewRulerLane.Right
          }
        }
      }));
      
      // Применяем только подчеркивание
      editor.deltaDecorations([], decorations);
      
      // Устанавливаем нужные опции
      editor.updateOptions({
        lineHeight: 18,
        glyphMargin: true,
        lineDecorationsWidth: 10,
        wordWrap: 'off'
      });
    }

    // Добавляем стили для тонкого подчеркивания
    const thinUnderlineStyleId = 'monaco-thin-underline-styles';
    if (!document.getElementById(thinUnderlineStyleId)) {
      const style = document.createElement('style');
      style.id = thinUnderlineStyleId;
      style.innerHTML = `
        /* Удаляем все существующие стили ошибок */
        .monaco-editor .squiggly-error,
        .monaco-editor .squiggly-warning,
        .monaco-editor .error-text,
        .monaco-editor .warning-text,
        .monaco-editor .cdr,
        .monaco-editor .cslr,
        .monaco-editor span[class*="error-"],
        .monaco-editor span[class*="warning-"] {
          background: transparent !important;
          background-color: transparent !important;
          border: none !important;
          border-radius: 0 !important;
          text-decoration: none !important;
        }
        
        /* Только тонкое подчеркивание для ошибок */
        .monaco-editor .thin-error-underline {
          border-bottom: 1px solid #FF4C4C !important;
          box-shadow: none !important;
          background: transparent !important;
        }
        
        /* Тонкое подчеркивание для предупреждений */
        .monaco-editor .thin-warning-underline {
          border-bottom: 1px solid #FFCC00 !important;
          box-shadow: none !important;
          background: transparent !important;
        }
        
        /* Фиксируем высоту строки */
        .monaco-editor .view-line {
          height: 18px !important;
          line-height: 18px !important;
          white-space: pre !important;
        }
      `;
      document.head.appendChild(style);
    }

    // Переопределяем глобальную функцию
    window.setupErrorDecorations = applyThinUnderlineDecorations;

    // Функция для обновления всех редакторов
    window.setupAllErrorDecorations = function() {
      if (window.monaco && window.monaco.editor) {
        const editors = window.monaco.editor.getEditors();
        editors.forEach(editor => {
          applyThinUnderlineDecorations(editor);
        });
      }
    };

    // Принудительное обновление
    window.forceUpdateAllDecorations = function() {
      if (window.monaco && window.monaco.editor) {
        const editors = window.monaco.editor.getEditors();
        editors.forEach(editor => {
          applyThinUnderlineDecorations(editor);
        });
      }
    };

    // Применяем к существующим редакторам
    if (window.monaco && window.monaco.editor) {
      setTimeout(() => {
        window.setupAllErrorDecorations();
      }, 500);
    }

    // Обработчик события обновления диагностики
    window.addEventListener('python-diagnostics-updated', () => {
      setTimeout(() => {
        window.setupAllErrorDecorations();
      }, 100);
    });

    // Обработчик для новых редакторов
    monaco.editor.onDidCreateEditor(editor => {
      setTimeout(() => {
        applyThinUnderlineDecorations(editor);
      }, 100);
    });

    /**
     * Функция для удаления всех стандартных декораций ошибок Monaco
     */
    function removeAllErrorDecorations(): void {
      // Создаем стиль, который скрывает все стандартные декорации ошибок
      const styleId = 'monaco-error-override-style';
      
      if (!document.getElementById(styleId)) {
        const style = document.createElement('style');
        style.id = styleId;
        style.innerHTML = `
          /* Полностью скрываем все стандартные декорации ошибок */
          .monaco-editor .squiggly-error,
          .monaco-editor .squiggly-warning,
          .monaco-editor .squiggly-info,
          .monaco-editor .squiggly-hint,
          .monaco-editor .error-text,
          .monaco-editor .warning-text,
          .monaco-editor .cdr,
          .monaco-editor .cslr,
          .monaco-editor span[class*="squiggly-"],
          .monaco-editor div[class*="squiggly-"],
          .monaco-editor .view-overlays .mtk-error,
          .monaco-editor .view-overlays .mtk-warn,
          .monaco-editor .view-overlays [class*="squiggly"],
          .monaco-editor .view-overlays [class*="error"],
          .monaco-editor .view-overlays [class*="warning"],
          .monaco-editor span[class*="error-"],
          .monaco-editor span[class*="warning-"],
          .monaco-editor div[class*="error-"],
          .monaco-editor div[class*="warning-"] {
            background: transparent !important;
            background-color: transparent !important;
            border: none !important;
            box-shadow: none !important;
            text-decoration: none !important;
            border-radius: 0 !important;
          }
          
          /* Сбрасываем и фоновые декорации строк */
          .monaco-editor .margin .margin-view-overlays .line-delete,
          .monaco-editor .margin .margin-view-overlays .line-insert,
          .monaco-editor .view-overlays .current-line,
          .monaco-editor .view-overlays .current-line-both,
          .monaco-editor .view-overlays .selection,
          .monaco-editor .view-overlays .view-line,
          .monaco-editor .view-overlays [class*="-line"] {
            background: transparent !important;
          }
          
          /* Применяем только тонкую линию подчеркивания для строк с ошибками */
          .monaco-editor .thin-error-underline {
            background: transparent !important;
            background-color: transparent !important;
            border-bottom: 1px solid #FF4C4C !important;
            box-shadow: none !important;
            position: relative !important;
            z-index: 100 !important;
          }
          
          /* Подчеркивание для предупреждений */
          .monaco-editor .thin-warning-underline {
            background: transparent !important;
            background-color: transparent !important;
            border-bottom: 1px solid #FFCC00 !important;
            box-shadow: none !important;
            position: relative !important;
            z-index: 100 !important;
          }
          
          /* Предотвращаем накладывание фона на строки */
          .monaco-editor .view-line span {
            background: transparent !important;
          }
        `;
        
        document.head.appendChild(style);
      }
    }

    /**
     * Функция для применения только тонких подчеркиваний
     */
    function applyOnlyUnderlineDecorations(editor: monaco.editor.IStandaloneCodeEditor): void {
      if (!editor || !editor.getModel) return;
      
      const model = editor.getModel();
      if (!model) return;
      
      // Очищаем абсолютно все существующие декорации
      const allDecorations = editor.getModel().getAllDecorations();
      const ids = allDecorations.map(d => d.id);
      editor.deltaDecorations(ids, []);
      
      // Получаем маркеры ошибок
      const markers = monaco.editor.getModelMarkers({ resource: model.uri });
      if (!markers || markers.length === 0) return;
      
      // Создаем только тонкие подчеркивания
      const decorations: monaco.editor.IModelDeltaDecoration[] = markers.map(marker => {
        // Создаем диапазон для декорации
        const range = new monaco.Range(
          marker.startLineNumber,
          marker.startColumn,
          marker.endLineNumber,
          marker.endColumn
        );
        
        // Определяем тип ошибки
        const isError = marker.severity === monaco.MarkerSeverity.Error;
        
        // Возвращаем только подчеркивание без фона
    return {
          range: range,
          options: {
            // Используем только класс для подчеркивания
            inlineClassName: isError ? 'thin-error-underline' : 'thin-warning-underline',
            // Добавляем сообщение при наведении
            hoverMessage: { value: marker.message },
            // Добавляем метку на мини-карте
            minimap: {
              color: isError ? '#FF4C4C' : '#FFCC00',
              position: monaco.editor.MinimapPosition.Inline
            },
            // Добавляем метку на полосе прокрутки
            overviewRuler: {
              color: isError ? '#FF4C4C' : '#FFCC00',
              position: monaco.editor.OverviewRulerLane.Right
            }
          }
        };
      });
      
      // Применяем только наши декорации
      editor.deltaDecorations([], decorations);
      
      // Настраиваем редактор для лучшего отображения
      editor.updateOptions({
        lineHeight: 18,
        glyphMargin: true,
        lineDecorationsWidth: 10,
        wordWrap: 'off'
      });
      
      // Принудительно обновляем отображение
      setTimeout(() => {
        editor.layout();
      }, 10);
    }

    // Инициализируем наши стили и удаляем стандартные
    removeAllErrorDecorations();

    // Сохраняем оригинальный метод установки маркеров
    const originalSetModelMarkers = monaco.editor.setModelMarkers;

    // Переопределяем метод setModelMarkers
    monaco.editor.setModelMarkers = function(
      model: monaco.editor.ITextModel, 
      owner: string, 
      markers: monaco.editor.IMarkerData[]
    ): void {
      // Вызываем оригинальный метод
      originalSetModelMarkers(model, owner, markers);
      
      // Обновляем декорации для всех редакторов
      setTimeout(() => {
        if (window.monaco && window.monaco.editor) {
          const editors = window.monaco.editor.getEditors();
          editors.forEach((editor: monaco.editor.IStandaloneCodeEditor) => {
            if (editor && editor.getModel() === model) {
              applyOnlyUnderlineDecorations(editor);
            }
          });
        }
      }, 0);
      
      // Для надежности также обновляем через небольшой интервал
      setTimeout(() => {
        if (window.monaco && window.monaco.editor) {
          const editors = window.monaco.editor.getEditors();
          editors.forEach((editor: monaco.editor.IStandaloneCodeEditor) => {
            if (editor && editor.getModel() === model) {
              applyOnlyUnderlineDecorations(editor);
            }
          });
        }
      }, 50);
    };

    // Переопределяем глобальную функцию
    window.setupErrorDecorations = applyOnlyUnderlineDecorations;

    // Функция для обновления всех редакторов
    window.setupAllErrorDecorations = function(): void {
      if (window.monaco && window.monaco.editor) {
        const editors = window.monaco.editor.getEditors();
        editors.forEach((editor: monaco.editor.IStandaloneCodeEditor) => {
          applyOnlyUnderlineDecorations(editor);
        });
      }
    };

    // Принудительное обновление
    window.forceUpdateAllDecorations = function(): void {
      removeAllErrorDecorations();
      if (window.monaco && window.monaco.editor) {
        const editors = window.monaco.editor.getEditors();
        editors.forEach((editor: monaco.editor.IStandaloneCodeEditor) => {
          applyOnlyUnderlineDecorations(editor);
        });
      }
    };

    // Применяем стили к существующим редакторам сразу и с задержкой
    if (window.monaco && window.monaco.editor) {
      try {
        if (window.forceUpdateAllDecorations) {
          window.forceUpdateAllDecorations();
        }
      } catch (e) {
        console.error('Ошибка при применении декораций:', e);
      }
      
      // Повторяем с задержкой для надежности
      setTimeout(() => {
        try {
          window.forceUpdateAllDecorations();
        } catch (e) {
          console.error('Ошибка при отложенном применении декораций:', e);
        }
      }, 500);
    }

    // Обработчик события обновления диагностики
    window.addEventListener('python-diagnostics-updated', () => {
      setTimeout(() => {
        try {
          window.forceUpdateAllDecorations();
        } catch (e) {
          console.error('Ошибка при обновлении декораций:', e);
        }
      }, 100);
    });

    // Обработчик для новых редакторов
    monaco.editor.onDidCreateEditor((editor: monaco.editor.IStandaloneCodeEditor) => {
      setTimeout(() => {
        try {
          removeAllErrorDecorations();
          applyOnlyUnderlineDecorations(editor);
        } catch (e) {
          console.error('Ошибка при применении декораций к новому редактору:', e);
        }
      }, 100);
    });

    /**
     * Функция для более агрессивного удаления декораций ошибок
     */
    function aggressiveErrorStyleRemoval() {
      // Создаем стиль, который категорически запрещает отображение стандартных декораций
      const styleId = 'monaco-super-aggressive-error-override';
      
      // Функция для инжекции стилей с максимальным приоритетом
      const injectHighPriorityStyle = (css) => {
        // Создаем новый элемент стиля
        const style = document.createElement('style');
        style.id = styleId + '-' + Math.random().toString(36).substring(2);
        style.innerHTML = css;
        style.setAttribute('data-priority', 'highest');
        
        // Вставляем стиль в начало head для максимального приоритета
        if (document.head.firstChild) {
          document.head.insertBefore(style, document.head.firstChild);
        } else {
          document.head.appendChild(style);
        }
        
        return style;
      };
      
      // МЕТОД 1: ПОЛНОЕ ПЕРЕОПРЕДЕЛЕНИЕ СТИЛЕЙ СТРОК И БЛОКОВ
      injectHighPriorityStyle(`
        /* ПОЛНОЕ УДАЛЕНИЕ БОЛЬШИХ ЛИНИЙ (МЕТОД 1) */
        
        /* Сначала полностью скрываем все декорации ошибок */
        .monaco-editor .squiggly-error,
        .monaco-editor .squiggly-warning,
        .monaco-editor .squiggly-info,
        .monaco-editor .squiggly-hint,
        .monaco-editor .error-text,
        .monaco-editor .warning-text,
        .monaco-editor .cdr,
        .monaco-editor .cslr,
        .monaco-editor .view-overlays .cdr,
        .monaco-editor .view-overlays .cslr,
        .monaco-editor .view-overlays .line-with-error,
        .monaco-editor .view-overlays .current-diagnostic-row,
        .monaco-editor span[class*="squiggly-"],
        .monaco-editor div[class*="squiggly-"],
        .monaco-editor .view-overlays .mtk-error,
        .monaco-editor .view-overlays .mtk-warn,
        .monaco-editor .view-overlays [class*="squiggly"],
        .monaco-editor .view-overlays [class*="error"],
        .monaco-editor .view-overlays [class*="warning"],
        .monaco-editor span[class*="error-"],
        .monaco-editor span[class*="warning-"],
        .monaco-editor div[class*="error-"],
        .monaco-editor div[class*="warning-"] {
          opacity: 0 !important;
          background: transparent !important;
          background-color: transparent !important;
          border: none !important;
          box-shadow: none !important;
          text-decoration: none !important;
        }
        
        /* Теперь явно переопределяем фон для всех строк */
        .monaco-editor .view-line,
        .monaco-editor .view-lines > div,
        .monaco-editor .view-lines .view-line,
        .monaco-editor .lines-content,
        .monaco-editor .lines-content .view-lines,
        .monaco-editor .view-overlays .view-line,
        .monaco-editor .view-overlays > div > div,
        .monaco-editor .view-overlays > div,
        .monaco-editor .view-overlays > div[class*="error"],
        .monaco-editor .view-overlays > div[class*="warning"],
        .monaco-editor .view-overlays > div[style*="background"],
        .monaco-editor .view-overlays > div[style*="background-color"] {
          background: transparent !important;
          background-color: transparent !important;
          background-image: none !important;
          border: none !important;
          box-shadow: none !important;
        }
        
        /* Подавляем встроенный line-height чтобы избежать растягивания строк */
        .monaco-editor .view-line,
        .monaco-editor .view-lines .view-line,
        .monaco-editor .view-lines > div,
        .monaco-editor .lines-content,
        .monaco-editor .lines-content .view-lines {
          height: 18px !important;
          line-height: 18px !important;
          min-height: 18px !important;
          max-height: 18px !important;
        }
        
        /* Наши собственные стили для подчеркивания */
        .monaco-editor .thin-error-underline {
          border-bottom: 1px wavy #FF4C4C !important;
          background: transparent !important;
          background-color: transparent !important;
        }
        
        .monaco-editor .thin-warning-underline {
          border-bottom: 1px wavy #FFCC00 !important;
          background: transparent !important;
          background-color: transparent !important;
        }
      `);
      
      // МЕТОД 2: CSS RESET ДЛЯ КАЖДОГО СВОЙСТВА КОТОРОЕ МОЖЕТ СОЗДАВАТЬ КРАСНЫЕ ЛИНИИ
      injectHighPriorityStyle(`
        /* ПОЛНОЕ УДАЛЕНИЕ БОЛЬШИХ ЛИНИЙ (МЕТОД 2) */
        
        /* Сбрасываем каждое свойство, которое может создавать красные линии */
        .monaco-editor *[class*="error"],
        .monaco-editor *[class*="warning"],
        .monaco-editor *[class*="squiggly"],
        .monaco-editor *[class*="diagnostic"],
        .monaco-editor *[class*="cdr"],
        .monaco-editor *[class*="cslr"],
        .monaco-editor .view-overlays > div,
        .monaco-editor .view-overlays .view-line,
        .monaco-editor .view-lines .view-line,
        .monaco-editor .lines-content .view-line,
        .monaco-editor .margin .margin-view-overlays .line-delete,
        .monaco-editor .margin .margin-view-overlays .line-insert {
          background: transparent !important;
          background-color: transparent !important;
          border-top: none !important;
          border-bottom: none !important;
          border-left: none !important;
          border-right: none !important;
          outline: none !important;
          text-decoration: none !important;
          box-shadow: none !important;
          opacity: 1 !important;
        }
        
        /* Особый случай - редактор Python полностью блокируем красные линии */
        .monaco-editor[data-mode="python"] .view-line,
        .monaco-editor[data-mode="python"] .view-lines > div,
        .monaco-editor[data-mode="python"] .view-overlays > div {
          background: transparent !important;
          background-color: transparent !important;
        }
      `);
      
      // МЕТОД 3: СПЕЦИАЛЬНЫЕ CASE ДЛЯ КАЖДОГО КОНКРЕТНОГО ВИДА ДЕКОРАЦИИ
      injectHighPriorityStyle(`
        /* ПОЛНОЕ УДАЛЕНИЕ БОЛЬШИХ ЛИНИЙ (МЕТОД 3) */
        
        /* Блокируем все возможные варианты декораций линий */
        .monaco-editor .view-overlays .current-line,
        .monaco-editor .view-overlays .current-line-both,
        .monaco-editor .view-overlays .line-with-error,
        .monaco-editor .view-overlays .error-line,
        .monaco-editor .view-overlays .warning-line,
        .monaco-editor .view-overlays .current-diagnostic-row,
        .monaco-editor .view-overlays .diagonal-fill,
        .monaco-editor .view-overlays .error-widget {
          background: transparent !important;
          background-color: transparent !important;
          border: none !important;
          box-shadow: none !important;
        }
        
        /* Дополнительно отключаем внутристрочные стили */
        .monaco-editor .mtk-error,
        .monaco-editor .mtk-warn,
        .monaco-editor .mtki,
        .monaco-editor .mtku {
          background: transparent !important;
          text-decoration: none !important;
          font-style: normal !important;
          font-weight: normal !important;
        }
        
        /* Для радикального решения - скрываем все inline стили */
        .monaco-editor .view-line span[style*="background"],
        .monaco-editor .view-line span[style*="border"],
        .monaco-editor .view-line span[style*="decoration"] {
          background: transparent !important;
          background-color: transparent !important;
          border: none !important;
          text-decoration: none !important;
        }
      `);
      
      // МЕТОД 4: ИНЖЕКЦИЯ JAVASCRIPT ДЛЯ АКТИВНОГО ИЗМЕНЕНИЯ DOM
      const cleanupAllErrorBackgrounds = () => {
        // 1. Находим все строки редактора
        const viewLines = document.querySelectorAll('.monaco-editor .view-line, .monaco-editor .view-overlays > div');
        viewLines.forEach(line => {
          if (line instanceof HTMLElement) {
            // Сбрасываем все возможные свойства для фона
            line.style.background = 'transparent';
            line.style.backgroundColor = 'transparent';
            line.style.borderTop = 'none';
            line.style.borderBottom = 'none';
            line.style.boxShadow = 'none';
            
            // Удаляем любые классы, связанные с ошибками
            if (line.className) {
              line.className = line.className
                .replace(/error/g, '')
                .replace(/warning/g, '')
                .replace(/squiggly/g, '')
                .replace(/cdr/g, '')
                .replace(/cslr/g, '')
                .replace(/diagnostic-row/g, '');
            }
            
            // Обрабатываем внутренние элементы
            const spans = line.querySelectorAll('span');
            spans.forEach(span => {
              if (span instanceof HTMLElement) {
                span.style.background = 'transparent';
                span.style.backgroundColor = 'transparent';
                span.style.borderBottom = 'none';
                span.style.textDecoration = 'none';
                span.style.boxShadow = 'none';
              }
            });
          }
        });
        
        // 2. Обрабатываем все элементы с классами, связанными с ошибками
        document.querySelectorAll('.monaco-editor [class*="error"], .monaco-editor [class*="warning"], .monaco-editor [class*="squiggly"]')
          .forEach(el => {
            if (el instanceof HTMLElement) {
              el.style.background = 'transparent';
              el.style.backgroundColor = 'transparent';
              el.style.borderBottom = 'none';
              el.style.boxShadow = 'none';
              el.style.textDecoration = 'none';
            }
          });
      };
      
      // Запускаем очистку сразу
      cleanupAllErrorBackgrounds();
      
      // Запускаем очистку с интервалом для гарантированного удаления красных линий
      const interval = setInterval(cleanupAllErrorBackgrounds, 100);
      
      // Через 5 секунд уменьшаем частоту очистки
      setTimeout(() => {
        clearInterval(interval);
        setInterval(cleanupAllErrorBackgrounds, 1000);
      }, 5000);
      
      // МЕТОД 5: MUTATION OBSERVER ДЛЯ МОМЕНТАЛЬНОЙ РЕАКЦИИ НА ИЗМЕНЕНИЯ DOM
      const setupDomObserver = () => {
        if (typeof MutationObserver === 'undefined') return;
        
        // Функция для быстрой проверки и очистки элемента
        const quickCleanup = (element) => {
          if (element instanceof HTMLElement) {
            const classes = element.className || '';
            const hasPotentialErrorClass = 
              classes.includes('error') || 
              classes.includes('warning') || 
              classes.includes('squiggly') ||
              classes.includes('diagnostic') ||
              classes.includes('cdr') ||
              classes.includes('cslr');
            
            // Если это элемент с классом ошибки - очищаем его
            if (hasPotentialErrorClass) {
              element.style.setProperty('background', 'transparent', 'important');
              element.style.setProperty('background-color', 'transparent', 'important');
              element.style.setProperty('border', 'none', 'important');
              element.style.setProperty('box-shadow', 'none', 'important');
              element.style.setProperty('text-decoration', 'none', 'important');
              return;
            }
            
            // Если это строка редактора - всегда очищаем
            if (
              element.classList.contains('view-line') || 
              (element.parentElement && element.parentElement.classList.contains('view-overlays'))
            ) {
              element.style.setProperty('background', 'transparent', 'important');
              element.style.setProperty('background-color', 'transparent', 'important');
            }
          }
        };
        
        // Создаем observer
        const observer = new MutationObserver(mutations => {
          mutations.forEach(mutation => {
            // Реагируем на изменения атрибутов
            if (mutation.type === 'attributes' && 
                (mutation.attributeName === 'class' || mutation.attributeName === 'style')) {
              quickCleanup(mutation.target);
            }
            
            // Реагируем на добавление новых элементов
            if (mutation.type === 'childList' && mutation.addedNodes.length) {
              mutation.addedNodes.forEach(node => {
                if (node instanceof HTMLElement) {
                  quickCleanup(node);
                  
                  // Также проверяем вложенные элементы
                  node.querySelectorAll('*').forEach(el => quickCleanup(el));
                }
              });
            }
          });
        });
        
        // Наблюдаем за всем документом
        observer.observe(document.body, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ['class', 'style']
        });
        
        return observer;
      };
      
      // Запускаем наблюдателя за DOM
      setupDomObserver();
      
      // МЕТОД 6: СЛУШАТЕЛИ СОБЫТИЙ РЕДАКТОРА ДЛЯ НЕМЕДЛЕННОЙ РЕАКЦИИ
      const setupEditorListeners = () => {
        if (!window.monaco || !window.monaco.editor) return;
        
        // Обработчик изменения содержимого модели
        window.monaco.editor.onDidChangeModelContent(() => {
          setTimeout(cleanupAllErrorBackgrounds, 0);
          setTimeout(cleanupAllErrorBackgrounds, 50);
          setTimeout(cleanupAllErrorBackgrounds, 100);
        });
        
        // Обработчик изменения позиции курсора
        window.monaco.editor.onDidChangeCursorPosition(() => {
          setTimeout(cleanupAllErrorBackgrounds, 0);
        });
        
        // Обработчик обновления диагностики
        window.addEventListener('python-diagnostics-updated', () => {
          setTimeout(cleanupAllErrorBackgrounds, 0);
          setTimeout(cleanupAllErrorBackgrounds, 100);
          setTimeout(cleanupAllErrorBackgrounds, 200);
        });
        
        // Обработчик создания нового редактора
        window.monaco.editor.onDidCreateEditor(editor => {
          setTimeout(cleanupAllErrorBackgrounds, 0);
          
          if (editor && editor.onDidChangeModelContent) {
            editor.onDidChangeModelContent(() => {
              setTimeout(cleanupAllErrorBackgrounds, 0);
            });
          }
        });
      };
      
      // Настраиваем слушатели событий редактора
      setupEditorListeners();
      
      // МЕТОД 7: ПЕРЕХВАТ API MONACO ДЛЯ ПРЕДОТВРАЩЕНИЯ ДОБАВЛЕНИЯ ДЕКОРАЦИЙ ОШИБОК
      const overrideMonacoAPI = () => {
        if (!window.monaco || !window.monaco.editor) return;
        
        // Сохраняем оригинальные методы
        const originalDeltaDecorations = window.monaco.editor.ITextModel.prototype.deltaDecorations;
        
        // Переопределяем метод deltaDecorations, чтобы фильтровать декорации ошибок
        window.monaco.editor.ITextModel.prototype.deltaDecorations = function(oldDecorations, newDecorations) {
          // Фильтруем декорации, удаляя те, которые могут создавать красные линии
          const filteredDecorations = newDecorations.filter(decoration => {
            if (!decoration || !decoration.options) return true;
            
            // Проверяем различные свойства, которые могут указывать на декорацию ошибки
            const className = decoration.options.className || '';
            const inlineClassName = decoration.options.inlineClassName || '';
            const hoverMessage = decoration.options.hoverMessage;
            
            const isErrorDecoration = 
              (className && (className.includes('error') || className.includes('warning'))) ||
              (inlineClassName && (inlineClassName.includes('error') || inlineClassName.includes('warning'))) ||
              decoration.options.isWholeLine === true;
            
            // Если это декорация ошибки, но не наше собственное подчеркивание - фильтруем
            if (isErrorDecoration && 
                !inlineClassName.includes('thin-error-underline') && 
                !inlineClassName.includes('thin-warning-underline')) {
              return false;
            }
            
            return true;
          });
          
          // Вызываем оригинальный метод с отфильтрованными декорациями
          return originalDeltaDecorations.call(this, oldDecorations, filteredDecorations);
        };
      };
      
      // Переопределяем API Monaco для предотвращения добавления декораций ошибок
      try {
        overrideMonacoAPI();
      } catch (e) {
        console.error('Не удалось переопределить API Monaco:', e);
      }
    }

    // Функция для применения только тонких подчеркиваний
    function applyOnlyUnderlineDecorations(editor) {
      if (!editor || !editor.getModel) return;
      
      const model = editor.getModel();
      if (!model) return;
      
      // Очищаем абсолютно все существующие декорации
      const allDecorations = editor.getModel().getAllDecorations();
      const ids = allDecorations.map(d => d.id);
      editor.deltaDecorations(ids, []);
      
      // Получаем только маркеры ошибок
      const markers = monaco.editor.getModelMarkers({ resource: model.uri })
        .filter(marker => marker.severity === monaco.MarkerSeverity.Error || 
                          marker.severity === monaco.MarkerSeverity.Warning);
      
      if (!markers || markers.length === 0) return;
      
      // Создаем только тонкие подчеркивания
      const decorations = markers.map(marker => {
        // Создаем диапазон для декорации
        const range = new monaco.Range(
          marker.startLineNumber,
          marker.startColumn,
          marker.endLineNumber,
          marker.endColumn
        );
        
        // Определяем тип ошибки
        const isError = marker.severity === monaco.MarkerSeverity.Error;
        
        // Возвращаем только тонкое подчеркивание без фона строки
        return {
          range: range,
          options: {
            inlineClassName: isError ? 'thin-error-underline' : 'thin-warning-underline',
            hoverMessage: { value: marker.message },
            // Важно: не используем isWholeLine
            isWholeLine: false,
            // Добавляем метку на мини-карте для удобства
            minimap: {
              color: isError ? '#FF4C4C' : '#FFCC00',
              position: monaco.editor.MinimapPosition.Inline
            },
            // Добавляем метку на полосе прокрутки
            overviewRuler: {
              color: isError ? '#FF4C4C' : '#FFCC00',
              position: monaco.editor.OverviewRulerLane.Right
            }
          }
        };
      });
      
      // Применяем только наши декорации
      editor.deltaDecorations([], decorations);
      
      // Принудительно применяем настройки редактора
      editor.updateOptions({
        lineHeight: 18,
        glyphMargin: true,
        lineDecorationsWidth: 10
      });
      
      // Немедленно перерисовываем редактор
      editor.layout();
      
      // Активно очищаем любые нежелательные декорации
      setTimeout(() => {
        // Принудительно очищаем все строки от фона
        const viewportElement = editor.getDomNode()?.querySelector('.view-lines');
        if (viewportElement instanceof HTMLElement) {
          const lines = viewportElement.querySelectorAll('.view-line');
          lines.forEach(line => {
            if (line instanceof HTMLElement) {
              line.style.background = 'transparent';
              line.style.backgroundColor = 'transparent';
            }
          });
        }
      }, 10);
    }

    return true;
  } catch (error) {
    console.error('Ошибка при регистрации Python:', error);
    return false;
  }
}